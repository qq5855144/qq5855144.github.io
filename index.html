    <!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Mgr</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/editor/editor.main.min.css">
    <script src="https://cdn.tailwindcss.com/3.3.3"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <style>
        /* ==================== 基础样式 ==================== */
:root {
    --glass-bg: rgba(255, 255, 255, 0.15);
    --glass-border: rgba(255, 255, 255, 0.2);
    --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    --glass-blur: blur(12px);
    --primary-color: #4f46e5;
    --text-primary: #1e293b;
    --text-secondary: #475569;
}

* {
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
    color: var(--text-primary);
    margin: 0;
    padding: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* ==================== 布局组件 ==================== */
.app-header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    padding: 1rem;
    height: 80px;
    box-sizing: border-box; 
}

.app-content {
    flex: 1;
    margin-top: calc(80px + 0.2rem) !important; 
    margin-bottom: 80px;
    padding: 1rem;
    overflow-y: auto;
}


.app-footer {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 1000;
    background: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    padding: 1rem;
}

/* ==================== 毛玻璃效果 ==================== */
.glass {
    background: var(--glass-bg);
    backdrop-filter: var(--glass-blur);
    -webkit-backdrop-filter: var(--glass-blur);
    border: 1px solid var(--glass-border);
    box-shadow: var(--glass-shadow);
    border-radius: 16px;
}

.glass-panel {
    background: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    border-radius: 16px;
}

/* ==================== 按钮样式 ==================== */
.glass-btn {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 16px 0 rgba(31, 38, 135, 0.1);
    border-radius: 12px;
    transition: all 0.3s ease;
    cursor: pointer;
    color: var(--text-primary);
    font-weight: 500;
}

.glass-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px 0 rgba(31, 38, 135, 0.2);
    background: rgba(255, 255, 255, 0.3);
}

.glass-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px 0 rgba(31, 38, 135, 0.1);
}

.glass-btn-primary {
    background: rgba(79, 70, 229, 0.8);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.glass-btn-primary:hover {
    background: rgba(79, 70, 229, 0.9);
}

/* ==================== 输入框样式 ==================== */
.glass-input {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    padding: 12px 16px;
    color: var(--text-primary);
    transition: all 0.3s ease;
    width: 100%;
}

.glass-input:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
    background: rgba(255, 255, 255, 0.3);
}

.glass-input::placeholder {
    color: rgba(71, 85, 105, 0.6);
}

/* ==================== 文件列表项样式 ==================== */
.file-item {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    transition: all 0.3s ease;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    padding: 12px;
    min-width: 0;
    overflow: hidden;
}

.file-item:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px 0 rgba(31, 38, 135, 0.1);
}

.file-item.selected {
    background: rgba(79, 70, 229, 0.2);
    border-color: rgba(79, 70, 229, 0.3);
}

/* 文件图标 */
.file-icon {
    margin-right: 12px;
    filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.1));
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
}

.folder-icon { color: #f59e0b; }
.archive-icon { color: #6366f1; }
.image-icon { color: #ec4899; }
.code-icon { color: #3b82f6; }
.text-icon { color: #64748b; }
.workflow-icon { color: #8b5cf6; }

/* 文件信息容器 */
.file-info-container {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    overflow: hidden;
}

.file-info-main .file-name {
    white-space: nowrap; 
    overflow: visible; 
    text-overflow: unset; 
    min-width: 0;
}

/* 第一行布局 - 确保名称和标签在同一行 */
.file-info-first-line {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 8px;
    margin-bottom: 4px;
    width: 100%;
    min-width: 0;
    flex-wrap: nowrap; /* 确保不换行 */
}

/* 文件名称 - 不换行 */
.file-name {
    font-weight: 600;
    font-size: 14px;
    color: var(--text-primary);
    line-height: 1.2;
    flex-shrink: 0;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-right: 0; /* 移除右边距 */
}

/* 仓库描述 */
.file-meta {
    font-size: 11px;
    color: var(--text-secondary);
    line-height: 1.3;
    margin-bottom: 4px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    max-height: 2.6em;
    width: 100%;
    text-align: left;
    word-break: break-word;
    overflow-wrap: break-word;
}

/* 文件统计信息 */
.file-stats {
    font-size: 10px;
    color: var(--text-secondary);
    line-height: 1.2;
    width: 100%;
    text-align: left;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-wrap: wrap;
    gap: 4px;
}

/* 标签容器 - 与名称在同一行 */
.repo-tags {
    display: flex;
    gap: 4px;
    flex-wrap: nowrap;
    flex-shrink: 0;
    justify-content: flex-start;
    align-items: center;
}

.repo-tag {
    font-size: 9px !important;
    padding: 1px 4px !important;
    border-radius: 6px !important;
    font-weight: 600;
    white-space: nowrap;
    line-height: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 50px;
}

/* 图标标签样式 */
.repo-tag-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 15px;
    height: 15px;
    border-radius: 4px;
    font-size: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.repo-tag-icon:hover {
    transform: scale(1.15);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
}

.tag-site {
    background: transparent;
    color: #16a34a;
}

.tag-release {
    background: transparent;
    color: #2563eb;
}

.tag-private {
    background: transparent;
    color: #6b7280;
}

/* 统计数据 */
.stats {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-start;
    flex-shrink: 0;
}

.star-stat, .fork-stat {
    display: flex;
    align-items: center;
    gap: 2px;
}

.update-time {
    font-size: 9px;
    color: #6b7280;
    white-space: nowrap;
    text-align: right;
}

/* ==================== 版本列表区域 ==================== */
#releases-section {
    margin: 1rem 0;
    padding: 1rem;
}

#releases-list .glass {
    transition: all 0.2s ease;
}

#releases-list .glass:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(31, 38, 135, 0.1);
}

#refresh-releases-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* ==================== 编辑器样式 ==================== */
#editor-container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 2000;
    background: white;
    display: none;
    flex-direction: column;
}

.editor-header {
    background: #2c3e50;
    color: white;
    padding: 12px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.editor-header h2 {
    font-size: 18px;
    font-weight: 600;
    margin: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 70%;
}

.editor-actions {
    display: flex;
    gap: 10px;
}

.editor-btn {
    padding: 8px 16px;
    border-radius: 6px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
}

.editor-btn-save {
    background: #4f46e5;
    color: white;
    border: none;
}

.editor-btn-save:hover {
    background: #4338ca;
}

.editor-btn-close {
    background: #e5e7eb;
    color: #4b5563;
    border: none;
}

.editor-btn-close:hover {
    background: #d1d5db;
}

#editor {
    flex: 1;
    min-height: 0;
}

/* 移动设备工具栏 */
.mobile-editor-toolbar {
    display: none;
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
    padding: 8px;
    gap: 8px;
    flex-wrap: wrap;
}

.mobile-toolbar-btn {
    flex: 1;
    min-width: 60px;
    padding: 8px;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    background: white;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
}

.editor-status-bar {
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
    padding: 8px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #6c757d;
}

.editor-status-item {
    display: flex;
    align-items: center;
    gap: 8px;
}

/* ==================== 工具栏和菜单 ==================== */
.toolbar {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
    border-radius: 24px;
    transition: transform 0.3s ease, opacity 0.3s ease;
}

.toolbar.hidden {
    transform: translateY(100px);
    opacity: 0;
    pointer-events: none;
}

/* 批量操作工具栏 */
.batch-toolbar {
    position: fixed;
    bottom: 80px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    gap: 8px;
    background: rgba(79, 70, 229, 0.9);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
    border-radius: 24px;
    padding: 8px 16px;
    color: white;
    font-weight: 500;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    z-index: 1000;
    margin: 0 auto;
    width: fit-content;
    max-width: 90%;
}

.batch-toolbar.visible {
    opacity: 1;
    pointer-events: auto;
}

.batch-toolbar-btn {
    background: rgba(255, 255, 255, 0.2);
    border: none;
    border-radius: 12px;
    padding: 8px 12px;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: all 0.2s;
}

.batch-toolbar-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* 用户菜单 */
.user-menu {
    position: relative;
    display: inline-block;
}

.user-menu-btn {
    display: flex;
    align-items: center;
    cursor: pointer;
}

.user-menu-content {
    position: absolute;
    right: 0;
    top: 100%;
    margin-top: 8px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
    border-radius: 12px;
    min-width: 180px;
    z-index: 1100;
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.2s ease;
    pointer-events: none;
}

.user-menu-content.show {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

.user-menu-item {
    padding: 10px 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: background 0.2s;
}

.user-menu-item:hover {
    background: rgba(0, 0, 0, 0.05);
}

/* ==================== 上下文菜单样式 ==================== */
.context-menu {
    position: fixed;
    z-index: 1000;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    min-width: 200px;
    overflow: hidden;
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.2s ease, opacity 0.2s ease;
    pointer-events: none;
    max-height: 80vh;
    overflow-y: auto;
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.context-menu.visible {
    transform: scale(1);
    opacity: 1;
    pointer-events: auto;
}

.context-menu-item {
    padding: 10px 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: background 0.2s;
}

.context-menu-item:hover {
    background: rgba(0, 0, 0, 0.05);
}

.context-menu-item i {
    margin-right: 10px;
    width: 20px;
    text-align: center;
}

.context-menu-divider {
    height: 1px;
    background: rgba(0, 0, 0, 0.1);
    margin: 4px 0;
}

.context-build-app {
    color: #3b82f6;
}

/* 搜索结果上下文菜单样式 */
#search-context-menu {
    position: fixed;
    z-index: 1000;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    min-width: 180px;
    overflow: hidden;
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.2s ease, opacity 0.2s ease;
    pointer-events: none;
    max-height: 80vh;
    overflow-y: auto;
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

#search-context-menu.visible {
    transform: scale(1);
    opacity: 1;
    pointer-events: auto;
}

/* 搜索结果文件上下文菜单样式 */
.search-file-context-menu {
    position: fixed;
    z-index: 1000;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    min-width: 180px;
    overflow: hidden;
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.2s ease, opacity 0.2s ease;
    pointer-events: none;
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.search-file-context-menu.visible {
    transform: scale(1);
    opacity: 1;
    pointer-events: auto;
}

/* ==================== 对话框样式 ==================== */
.dialog-overlay {
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    z-index: 999;
}

.dialog-content {
    background: rgba(255, 255, 255, 0.98);
    border-radius: 10px;
    padding: 14px 16px;
    width: 85%;
    max-width: 340px;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
}

.dialog-content h3 {
    font-size: 1.1rem;
    margin-bottom: 0.6rem;
}

.dialog-input {
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.08);
    border-radius: 5px;
    padding: 8px 12px;
    font-size: 0.85rem;
    height: 36px;
    margin-bottom: 0.6rem;
}

.dialog-buttons {
    margin-top: 0.8rem;
    gap: 6px;
}

.dialog-btn {
    padding: 6px 12px;
    font-size: 0.85rem;
    border-radius: 5px;
}

/* ==================== 面包屑导航 ==================== */
#path-container {
    min-width: 0;
    overflow-x: auto;
    scrollbar-width: thin;
}

#path-container::-webkit-scrollbar {
    height: 4px;
}

#path-container::-webkit-scrollbar-thumb {
    background-color: rgba(79, 70, 229, 0.3);
    border-radius: 2px;
}

#path-container::-webkit-scrollbar-track {
    background: transparent;
}

.breadcrumb {
    display: flex;
    align-items: center;
    flex-wrap: nowrap;
    white-space: nowrap;
}

.breadcrumb-item {
    display: flex;
    align-items: center;
    cursor: pointer;
    transition: color 0.2s;
}

.breadcrumb-item:hover {
    color: var(--primary-color);
}

.breadcrumb-separator {
    margin: 0 8px;
    color: var(--text-secondary);
}

.breadcrumb-item i.fab.fa-github {
    font-size: 20px;
    color: #4f46e5;
    transition: all 0.3s;
}

/* ==================== 搜索相关样式 ==================== */
.search-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

.search-overlay-content {
    position: relative;
    width: 90%;
    max-width: 600px;
    margin-top: 15vh;
}


.search-overlay-close:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(1.1);
}

/* 搜索类型选择器样式 */
.search-type-selector {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
    justify-content: center;
    flex-wrap: wrap;
}

.search-type-btn {
    background: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 20px;
    padding: 8px 16px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 14px;
    font-weight: 500;
    white-space: nowrap;
}

.search-type-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-2px);
}

.search-type-btn.active {
    background: rgba(79, 70, 229, 0.8);
    border-color: rgba(255, 255, 255, 0.5);
}

/* 搜索提示文本 */
.search-hint {
    text-align: center;
    color: rgba(255, 255, 255, 0.7);
    font-size: 14px;
    margin-bottom: 12px;
}

/* 搜索输入框和排序按钮容器 */
.search-sort-container {
    position: relative;
    width: 100%;
}

/* 左侧排序按钮 */
.search-sort-btn {
    position: absolute;
    left: 16px;
    top: 50%;
    transform: translateY(-50%);
    z-index: 10;
    background: rgba(255,255,255,0.2);
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
    color: #64748b;
}

.search-sort-btn:hover {
    background: rgba(255,255,255,0.3);
    color: #4f46e5;
    transform: translateY(-50%) scale(1.05);
}

/* 搜索输入框 */
.search-overlay-input {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 16px;
    padding: 16px 20px 16px 60px !important;
    font-size: 18px;
    width: 100%;
    box-sizing: border-box;
    box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
    transition: all 0.3s ease;
}

.search-overlay-input:focus {
    outline: none;
    box-shadow: 0 8px 32px 0 rgba(79, 70, 229, 0.3);
    transform: translateY(-2px);
}

/* 搜索历史样式 */
.search-history {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    border-radius: 12px;
    margin-top: 12px;
    max-height: 200px;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    width: 100%;
    box-sizing: border-box;
}

.search-history-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 12px;
    cursor: pointer;
    transition: background 0.2s;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    font-size: 14px;
}

.search-history-item:last-child {
    border-bottom: none;
}

.search-history-item:hover {
    background: rgba(0, 0, 0, 0.03);
}

.search-history-text {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 8px;
}

.search-history-delete {
    background: none;
    border: none;
    color: #6b7280;
    cursor: pointer;
    padding: 4px;
    border-radius: 4px;
    transition: all 0.2s;
}

.search-history-delete:hover {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
}

/* 排序菜单样式 */
.search-sort-context-menu {
    position: fixed;
    z-index: 2001;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    min-width: 160px;
    overflow: hidden;
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.2s ease, opacity 0.2s ease;
    pointer-events: none;
}

.search-sort-context-menu.visible {
    transform: scale(1);
    opacity: 1;
    pointer-events: auto;
}

.search-sort-menu-item {
    padding: 10px 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: background 0.2s;
    font-size: 14px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.search-sort-menu-item:last-child {
    border-bottom: none;
}

.search-sort-menu-item:hover {
    background: rgba(0, 0, 0, 0.03);
}

.search-sort-menu-item.active {
    background: rgba(79, 70, 229, 0.1);
    color: #4f46e5;
    font-weight: 600;
}

.search-sort-menu-item i {
    margin-right: 10px;
    width: 18px;
    text-align: center;
    font-size: 16px;
}

/* ==================== 图片预览样式 ==================== */
.image-preview-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2000;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

.image-preview-content {
    position: relative;
    z-index: 1;
    max-width: 90%;
    max-height: 90%;
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.image-preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
}

.image-preview-title {
    font-weight: 600;
    font-size: 16px;
    color: #333;
}

.image-preview-close {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    color: #6c757d;
    padding: 4px;
    border-radius: 4px;
    transition: all 0.2s;
}

.image-preview-close:hover {
    background: #e9ecef;
    color: #495057;
}

.image-preview-body {
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: white;
    flex: 1;
}

.image-preview-body img {
    max-width: 100%;
    max-height: 70vh;
    object-fit: contain;
    border-radius: 6px;
}

.image-preview-footer {
    padding: 12px 16px;
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
    display: flex;
    justify-content: center;
}

.background-toggle {
    display: flex;
    gap: 8px;
}

.btn-bg-light, .btn-bg-dark, .btn-bg-grid {
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 8px 12px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 4px;
}

.btn-bg-light:hover, .btn-bg-dark:hover, .btn-bg-grid:hover {
    background: #e9ecef;
}

/* 背景样式 */
.light-bg {
    background: white;
}

.checkerboard-bg {
    background-image: 
        linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
        linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
        linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
}

.checkerboard-dark-bg {
    background-image: 
        linear-gradient(45deg, #e0e0e0 25%, transparent 25%),
        linear-gradient(-45deg, #e0e0e0 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #e0e0e0 75%),
        linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
}

.loading-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #6c757d;
    font-size: 14px;
}

/* ==================== 构建状态样式 ==================== */
.build-status {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2000;
    min-width: 300px;
    max-width: 90%;
}

#build-progress {
    margin-top: 8px;
}

#progress-bar {
    transition: width 0.3s ease;
}

#progress-text {
    font-size: 11px;
    color: #6b7280;
}

/* ==================== 工具类 ==================== */
.hidden {
    display: none !important;
}

/* 加载动画 */
@keyframes spin {
    to { transform: rotate(360deg); }
}

.animate-spin {
    animation: spin 1s linear infinite;
}

/* 滚动条样式 */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: rgba(79, 70, 229, 0.5);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(79, 70, 229, 0.7);
}

/* ==================== 响应式设计 ==================== */

/* 平板设备 */
@media (max-width: 768px) {
    .app-header {
        padding: 0.75rem;
    }

    .app-content {
        margin-top: 70px;
        margin-bottom: 70px;
        padding: 0.75rem;
    }

    .app-footer {
        padding: 0.75rem;
    }

    .file-item {
        padding: 10px !important;
        min-height: 60px !important;
    }

    .file-name {
        font-size: 13px;
        max-width: 55%;
    }

    .file-meta {
        font-size: 10px;
        -webkit-line-clamp: 1;
        max-height: 1.2em;
    }

    .file-stats {
        font-size: 9px;
    }

    .repo-tag {
        font-size: 8px !important;
        padding: 1px 3px !important;
        max-width: 45px;
    }

    .repo-tags {
        max-width: 40%;
    }

    .editor-status-bar {
        display: none;
    }

    .editor-header {
        padding: 10px 15px;
        flex-wrap: wrap;
    }

    .editor-header h2 {
        font-size: 16px;
        max-width: 60%;
    }

    .editor-actions {
        flex-wrap: wrap;
        gap: 5px;
    }

    .editor-btn {
        padding: 6px 12px;
        font-size: 14px;
    }

    .mobile-editor-toolbar {
        display: flex;
    }

    /* 搜索相关移动端适配 */
    .search-overlay-content {
        margin-top: 10vh;
        width: 95%;
    }
    
    .search-type-selector {
        gap: 6px;
    }
    
    .search-type-btn {
        padding: 6px 12px;
        font-size: 13px;
    }
    
    .search-overlay-input {
        padding: 14px 16px 14px 55px !important;
        font-size: 16px;
    }
    
    .search-sort-btn {
        width: 32px;
        height: 32px;
        left: 12px;
    }
}

/* 手机设备 */
@media (max-width: 480px) {
    .file-info-first-line {
        flex-wrap: nowrap; 
        overflow-x: auto; 
    }


    .app-content {
        margin-top: 60px;
        margin-bottom: 60px;
        padding: 0.5rem;
    }

    .app-footer {
        padding: 0.5rem;
    }

    .file-item {
        padding: 8px 10px !important;
        min-height: 55px !important;
    }

    .file-info-first-line {
        flex-wrap: wrap;
        gap: 4px;
    }

    .file-name {
        flex-shrink: 0;
    }

    .repo-tags {
        flex-shrink: 0; 
    }


    .file-meta {
        order: 3;
    }

    .file-stats {
        order: 4;
        flex-direction: row;
        align-items: center;
        justify-content: space-between;
    }

    .file-icon {
        width: 32px !important;
        height: 32px !important;
        margin-right: 8px !important;
    }

    .dialog-content {
        padding: 12px 14px;
        max-width: 300px;
    }

    .dialog-input {
        padding: 7px 10px;
        height: 34px;
    }

    .dialog-btn {
        padding: 5px 10px;
    }

    .batch-toolbar {
        bottom: 70px;
        padding: 6px 12px;
    }

    .batch-toolbar-btn {
        padding: 6px 8px;
        font-size: 14px;
    }

    .glass {
        border-radius: 12px;
    }

    .toolbar {
        padding: 8px;
        border-radius: 20px;
    }

    .breadcrumb {
        font-size: 14px;
    }

    .repo-tags {
        max-width: 35%;
    }
}

/* 超小屏幕设备 */
@media (max-width: 360px) {
    .file-item {
        padding: 6px 8px !important;
    }

    .file-name {
        font-size: 12px;
    }

    .file-meta {
        font-size: 9px;
    }

    .repo-tag {
        font-size: 7px !important;
        max-width: 40px;
    }

    .stats {
        gap: 4px;
    }

    .repo-tags {
        max-width: 30%;
    }
    
    .repo-tag {
        font-size: 6px !important;
        max-width: 35px;
        padding: 0 2px !important;
    }
}
    </style>
</head>
<body>
    <!-- 认证界面 -->
    <div id="auth-screen" class="flex flex-col items-center justify-center min-h-screen p-4">
        <div class="glass-panel p-8 w-full max-w-md mx-auto">
            <div class="text-center mb-8">
                <i class="fab fa-github text-5xl mb-4" style="color: var(--primary-color);"></i>
                <h1 class="text-3xl font-bold text-gray-800 mb-2">GitHub Mgr</h1>
                <p class="text-gray-600">使用您的 GitHub Token 登录</p>
            </div>
            
            <div class="mb-6">
                <input type="text" id="github-token" placeholder="输入您的 GitHub Token" 
                       class="glass-input mb-1">
                <p id="token-error" class="text-red-500 text-sm hidden"></p>
            </div>
            
            <button id="auth-btn" class="glass-btn glass-btn-primary w-full py-3 font-medium flex items-center justify-center">
                <span id="auth-btn-text">认证并继续</span>
                <i id="auth-spinner" class="fas fa-spinner fa-spin ml-2 hidden"></i>
            </button>
            
            <div class="mt-8 text-sm text-gray-600">
                <p class="font-medium mb-2">如何获取 Token？</p>
                <ol class="list-decimal pl-5 space-y-1">
                    <li>登录 GitHub 账户</li>
                    <li>访问 <a href="https://github.com/settings/tokens" target="_blank" class="text-blue-500 hover:underline">开发者设置</a></li>
                    <li>创建新的个人访问令牌</li>
                    <li>勾选 repo 权限</li>
                </ol>
            </div>
        </div>
    </div>
    
    <!-- 主界面 -->
    <div id="main-screen" class="hidden flex flex-col min-h-screen">
        <!-- 页头 -->
        <header class="app-header">
            <div class="max-w-6xl mx-auto flex items-center justify-between">
                <!-- 路径显示 -->
                <div id="path-container" class="flex-1 min-w-0 overflow-x-auto">
                    <div id="current-path" class="text-lg font-semibold">
                        <div class="breadcrumb whitespace-nowrap">
                            <div class="breadcrumb-item" onclick="loadRepositories()">
                                <i class="fab fa-github mr-1"></i>
                                <span>我的仓库</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 用户菜单 -->
                <div class="user-menu">
                    <div id="user-menu-btn" class="user-menu-btn glass-btn p-2">
                        <i class="fas fa-user-circle text-lg"></i>
                    </div>
                    <div id="user-menu-content" class="user-menu-content">
                        <div id="user-info" class="user-menu-item">
                            <i class="fas fa-user"></i>
                            <span id="username"></span>
                        </div>
                        <div class="user-menu-divider"></div>
                        <div id="logout-btn" class="user-menu-item">
                            <i class="fas fa-sign-out-alt text-red-500"></i>
                            <span class="text-red-500">退出登录</span>
                        </div>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- 内容区 -->
<main class="app-content">
    <div class="max-w-6xl mx-auto">
        <div id="loading" class="flex justify-center items-center h-64">
            <div class="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-500"></div>
        </div>
        
        <div id="file-list" class="grid gap-3 hidden">
            <!-- 动态生成的文件列表 -->
        </div>
        
        <div id="empty-state" class="hidden flex flex-col items-center justify-center h-64 text-gray-500">
            <i class="fas fa-folder-open text-5xl mb-4 opacity-50"></i>
            <p class="text-lg">当前目录为空</p>
        </div>
        
        <!-- 版本列表区域（新增完整DOM结构） -->
        <div id="releases-section" class="glass-panel mt-4 p-4">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-semibold flex items-center">
                    <i class="fas fa-box-archive mr-2 text-blue-500"></i>
                    发行版本
                </h3>
                <button id="refresh-releases-btn" class="glass-btn p-2 text-sm">
                    <i class="fas fa-sync-alt mr-1"></i> 刷新
                </button>
            </div>
            <div id="releases-loading" class="flex justify-center items-center h-24">
                <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-500"></div>
            </div>
            <div id="releases-list" class="hidden space-y-3"></div>
            <div id="releases-empty" class="hidden flex flex-col items-center justify-center h-24 text-gray-500">
                <i class="fas fa-box-open text-4xl mb-2 opacity-50"></i>
                <p>暂无发布版本</p>
            </div>
        </div>
    </div>
</main>

        
       <!-- 页脚 -->
        <footer class="app-footer">
            <div class="max-w-6xl mx-auto flex justify-center gap-3">        
                <button id="new-repo-btn" class="glass-btn p-3" title="新建仓库">
                    <i class="fas fa-plus text-blue-500"></i>
                </button>
                <button id="fork-repo-btn" class="glass-btn p-3 hidden" title="复刻仓库">
                    <i class="fas fa-code-branch text-purple-500"></i>
                </button>       
                <button id="new-folder-btn" class="glass-btn p-3 hidden" title="新建文件夹">
                    <i class="fas fa-folder-plus text-amber-500"></i>
                </button>
                <button id="upload-btn" class="glass-btn p-3 hidden" title="上传文件">
                    <i class="fas fa-upload text-violet-500"></i>
                </button>
                <button id="select-btn" class="glass-btn p-3 hidden" title="选择文件">
                    <i class="fas fa-check-square text-blue-500"></i>
                </button>
                <!-- 修改搜索按钮 -->
                <button id="search-repo-btn" class="glass-btn p-3" title="搜索仓库">
                    <i class="fas fa-search text-green-500"></i>
                </button>
            </div>
        </footer>
        
        <!-- 批量操作工具栏 -->
        <div id="batch-toolbar" class="batch-toolbar">
            <div class="batch-count">
                <i class="fas fa-check-circle mr-2"></i>
                <span id="selected-count">0</span> 已选
            </div>
            <button id="batch-download-btn" class="batch-toolbar-btn" title="下载选中文件">
                <i class="fas fa-download"></i>
                <span>下载</span>
            </button>
            <button id="batch-delete-btn" class="batch-toolbar-btn" title="删除选中文件">
                <i class="fas fa-trash"></i>
                <span>删除</span>
            </button>
            <button id="batch-cancel-btn" class="batch-toolbar-btn" title="取消选择">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    
    <!-- 编辑器容器 -->
    <div id="editor-container" class="fixed inset-0 z-[2000] hidden flex-col bg-white">
        <div class="editor-header">
            <h2 id="editor-filename"></h2>
            <div class="editor-actions">
                <button id="editor-save-btn" class="editor-btn editor-btn-save">保存</button>
                <button id="editor-close-btn" class="editor-btn editor-btn-close">关闭</button>
            </div>
        </div>
        <div id="editor"></div>
        <!-- 移动设备工具栏 -->
        <div class="mobile-editor-toolbar">
            <button class="mobile-toolbar-btn" id="mobile-save-btn">
                <i class="fas fa-save"></i> 
            </button>
            <button class="mobile-toolbar-btn" id="mobile-close-btn">
                <i class="fas fa-times"></i> 
            </button>
            <button class="mobile-toolbar-btn" id="mobile-undo-btn">
                <i class="fas fa-undo"></i> 
            </button>
            <button class="mobile-toolbar-btn" id="mobile-redo-btn">
                <i class="fas fa-redo"></i> 
            </button>
            <button class="mobile-toolbar-btn" id="mobile-search-btn">
                <i class="fas fa-search"></i> 
            </button>
        </div>
        <div class="editor-status-bar">
            <div class="editor-status-item">
                <span id="editor-file-size"></span>
            </div>
            <div class="editor-status-item">
                <span id="editor-language"></span>
            </div>
        </div>
    </div>
    
    <!-- 操作提示 -->
    <div id="toast" class="fixed bottom-20 left-1/2 transform -translate-x-1/2 glass-panel px-6 py-3 rounded-full opacity-0 transition-opacity duration-300 text-sm font-medium">
        <!-- 提示内容 -->
    </div>
    
    <!-- 确认对话框 -->
    <div id="confirm-dialog" class="fixed inset-0 z-50 dialog-overlay flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300">
        <div id="confirm-content" class="dialog-content p-6 rounded-xl w-full max-w-md transform scale-90 transition-transform duration-300">
            <h3 id="confirm-title" class="text-xl font-bold mb-2">确认删除</h3>
            <p id="confirm-message" class="text-gray-700 mb-6">您确定要删除这个文件吗？此操作不可撤销。</p>
            <div id="confirm-buttons" class="flex justify-end gap-3">
                <button id="confirm-no" class="glass-btn px-4 py-2">取消</button>
                <button id="confirm-yes" class="glass-btn glass-btn-primary px-4 py-2">确认删除</button>
            </div>
        </div>
    </div>
    
    <!-- 新建文件夹对话框 -->
    <div id="new-folder-dialog" class="fixed inset-0 z-50 dialog-overlay flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300">
        <div id="new-folder-content" class="dialog-content p-6 rounded-xl w-full max-w-md transform scale-90 transition-transform duration-300">
            <h3 id="new-folder-title" class="text-xl font-bold mb-2">新建文件夹</h3>
            <input type="text" id="new-folder-name" placeholder="文件夹名称" class="glass-input mb-4">
            <div id="new-folder-buttons" class="flex justify-end gap-3">
                <button id="new-folder-cancel" class="glass-btn px-4 py-2">取消</button>
                <button id="new-folder-create" class="glass-btn glass-btn-primary px-4 py-2">创建</button>
            </div>
        </div>
    </div>
    
    <!-- 新建仓库对话框 -->
    <div id="new-repo-dialog" class="fixed inset-0 z-50 dialog-overlay flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300">
        <div id="new-repo-content" class="dialog-content p-6 rounded-xl w-full max-w-md transform scale-90 transition-transform duration-300">
            <h3 id="new-repo-title" class="text-xl font-bold mb-2">新建仓库</h3>
            <input type="text" id="new-repo-name" placeholder="仓库名称" class="glass-input mb-3">
            <input type="text" id="new-repo-desc" placeholder="仓库描述 (可选)" class="glass-input mb-3">
            <div class="flex items-center mb-4">
                <input type="checkbox" id="new-repo-private" class="mr-2">
                <label for="new-repo-private">私有仓库</label>
            </div>
            <div id="new-repo-buttons" class="flex justify-end gap-3">
                <button id="new-repo-cancel" class="glass-btn px-4 py-2">取消</button>
                <button id="new-repo-create" class="glass-btn glass-btn-primary px-4 py-2">创建</button>
            </div>
        </div>
    </div>

    <!-- 复刻仓库对话框 -->
    <div id="fork-repo-dialog" class="fixed inset-0 z-50 dialog-overlay flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300">
        <div id="fork-repo-content" class="dialog-content p-6 rounded-xl w-full max-w-md transform scale-90 transition-transform duration-300">
            <h3 id="fork-repo-title" class="text-xl font-bold mb-2">复刻仓库</h3>
            <input type="text" id="fork-repo-url" placeholder="输入GitHub仓库URL" class="glass-input mb-4">
            <div id="fork-repo-buttons" class="flex justify-end gap-3">
                <button id="fork-repo-cancel" class="glass-btn px-4 py-2">取消</button>
                <button id="fork-repo-confirm" class="glass-btn glass-btn-primary px-4 py-2">复刻</button>
            </div>
        </div>
    </div>

    <!-- 上传文件对话框 -->
    <div id="upload-dialog" class="fixed inset-0 z-50 dialog-overlay flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300">
        <div id="upload-content" class="dialog-content p-6 rounded-xl w-full max-w-md transform scale-90 transition-transform duration-300">
            <h3 id="upload-title" class="text-xl font-bold mb-2">上传文件</h3>
            <input type="file" id="file-input" class="glass-input mb-4" multiple>
            <div id="upload-buttons" class="flex justify-end gap-3">
                <button id="upload-cancel" class="glass-btn px-4 py-2">取消</button>
                <button id="upload-file" class="glass-btn glass-btn-primary px-4 py-2">上传</button>
            </div>
        </div>
    </div>
    
    <!-- 上下文菜单 -->
<div id="context-menu" class="context-menu">
    <div id="context-open" class="context-menu-item">
        <i class="fas fa-folder-open"></i>
        <span>打开</span>
    </div>
    <div class="context-menu-divider"></div>  
    <div id="context-copy-repo-link" class="context-menu-item">
        <i class="fas fa-link"></i>
        <span>复制仓库链接</span>
    </div>
    <div id="context-copy-site-link" class="context-menu-item">
        <i class="fas fa-globe"></i>
        <span>复制网站链接</span>
    </div>
    <div id="context-rename-repo" class="context-menu-item">
        <i class="fas fa-edit"></i>
        <span>重命名仓库</span>
    </div>
    <div id="context-download" class="context-menu-item">
        <i class="fas fa-download"></i>
        <span>下载</span>
    </div>
    <div id="context-rename" class="context-menu-item">
        <i class="fas fa-edit"></i>
        <span>重命名</span>
    </div>
    <div id="context-copy-link" class="context-menu-item">
        <i class="fas fa-link"></i>
        <span>复制链接</span>
    </div>
    <div id="context-copy-proxy-link" class="context-menu-item">
        <i class="fas fa-share-alt"></i>
        <span>复制代理链接</span>
    </div>
    <div id="context-download-source" class="context-menu-item">
        <i class="fas fa-download text-blue-500"></i>
        <span class="text-blue-500">下载源码</span>
    </div>
    <div id="context-build-app" class="context-menu-item context-build-app">
        <i class="fas fa-hammer"></i>
        <span>运行工作流</span>
    </div>
    <div id="context-enable-pages" class="context-menu-item">
        <i class="fas fa-globe text-green-500"></i>
        <span class="text-green-500">部署网站</span>
    </div>
    <div class="context-menu-divider"></div>
    <div id="context-delete" class="context-menu-item">
        <i class="fas fa-trash text-red-500"></i>
        <span class="text-red-500">删除</span>
    </div>
</div>

    
    <!-- 搜索结果上下文菜单 -->
<div id="search-context-menu" class="context-menu">
    <div id="search-context-fork" class="context-menu-item">
        <i class="fas fa-code-branch text-blue-500"></i>
        <span class="text-blue-500">复刻仓库</span>
    </div>
    <div id="search-context-copy-link" class="context-menu-item">
        <i class="fas fa-link"></i>
        <span>复制仓库链接</span>
    </div>
    <div id="search-context-visit" class="context-menu-item">
        <i class="fas fa-external-link-alt"></i>
        <span>访问仓库</span>
    </div>
</div>

<!-- 新增：搜索结果文件上下文菜单 -->
<div id="search-file-context-menu" class="search-file-context-menu">
    <div id="search-file-open" class="context-menu-item">
        <i class="fas fa-folder-open"></i>
        <span>打开</span>
    </div>
    <div id="search-file-download" class="context-menu-item">
        <i class="fas fa-download"></i>
        <span>下载</span>
    </div>
    <div class="context-menu-divider"></div>
    <div id="search-file-copy-link" class="context-menu-item">
        <i class="fas fa-link"></i>
        <span>复制链接</span>
    </div>
    <div id="search-file-copy-proxy-link" class="context-menu-item">
        <i class="fas fa-share-alt"></i>
        <span>复制代理链接</span>
    </div>
</div>
    
    <!-- 添加部署网站配置对话框 -->
    <div id="static-site-dialog" class="fixed inset-0 z-50 dialog-overlay flex items-center justify-center p-4 opacity-0 pointer-events-none transition-opacity duration-300">
        <div id="static-site-content" class="dialog-content p-6 rounded-xl w-full max-w-md transform scale-90 transition-transform duration-300">
            <h3 id="static-site-title" class="text-xl font-bold mb-4">部署网站配置</h3>
            
            <div class="mb-4">
                <label class="block text-gray-700 mb-2 font-medium">分支</label>
                <select id="pages-branch" class="glass-input mb-1">
                    <option value="main">main</option>
                    <option value="master">master</option>
                    <option value="gh-pages">gh-pages</option>
                </select>
            </div>
            
            <div class="mb-4">
                <label class="block text-gray-700 mb-2 font-medium">目录</label>
                <select id="pages-folder" class="glass-input mb-1">
                    <option value="/">根目录</option>
                    <option value="/docs">docs 文件夹</option>
                </select>
            </div>
            
            <div id="pages-status" class="mb-4 hidden">
                <div class="flex items-center">
                    <i class="fas fa-circle text-green-500 mr-2"></i>
                    <span class="font-medium">网站已启用</span>
                </div>
                <div class="mt-2">
                    <span class="text-sm">访问地址: </span>
                    <a id="pages-url" href="#" target="_blank" class="text-blue-500 text-sm hover:underline"></a>
                </div>
            </div>
            
            <div id="static-site-buttons" class="flex justify-end gap-3">
                <button id="static-site-cancel" class="glass-btn px-4 py-2">取消</button>
                <button id="static-site-enable" class="glass-btn glass-btn-primary px-4 py-2">启用</button>
            </div>
        </div>
    </div>
    
    <!-- 新增构建状态提示 -->
    <div id="build-status" class="build-status glass-panel p-4 hidden">
        <div class="flex items-center mb-2">
            <i id="build-icon" class="fas fa-cog animate-spin text-blue-500 mr-2"></i>
            <h3 class="font-semibold">构建状态</h3>
            <button id="close-build-status" class="ml-auto text-gray-500 hover:text-gray-700">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div id="build-message" class="text-sm"></div>
        <div id="build-progress" class="mt-2">
            <div class="w-full bg-gray-200 rounded-full h-2">
                <div id="progress-bar" class="bg-blue-500 h-2 rounded-full" style="width: 0%"></div>
            </div>
            <div id="progress-text" class="text-xs text-right mt-1">0%</div>
        </div>
    </div> 
    
   <!-- 更新搜索遮罩层HTML结构 -->
<div id="search-overlay" class="search-overlay hidden">
    <div class="search-overlay-content">
          
        <!-- 搜索类型选择器 -->
        <div class="search-type-selector">
            <button class="search-type-btn active" data-type="repositories">
                <i class="fas fa-book"></i> 仓库
            </button>
            <button class="search-type-btn" data-type="code">
                <i class="fas fa-code"></i> 代码
            </button>
            <button class="search-type-btn" data-type="issues">
                <i class="fas fa-exclamation-circle"></i> Issues
            </button>
            <button class="search-type-btn" data-type="users">
                <i class="fas fa-users"></i> 用户
            </button>
        </div>
        
        <!-- 搜索提示 -->
        <div class="search-hint" id="search-hint">
            搜索 GitHub 仓库
        </div>
        
        <!-- 搜索输入框和排序按钮容器 -->
        <div class="search-sort-container">
            <!-- 左侧排序按钮 -->
            <div id="search-sort-btn" class="search-sort-btn">
                <i class="fas fa-clock"></i>
            </div>
            <!-- 搜索输入框 -->
            <input type="text" id="search-overlay-input" class="search-overlay-input" 
                   placeholder="搜索仓库名称、描述...">
        </div>
        
        <!-- 搜索历史 -->
        <div id="search-history" class="search-history hidden"></div>
    </div>
</div>

<!-- 排序菜单 -->
<div id="search-sort-context-menu" class="search-sort-context-menu">
    <div class="search-sort-menu-item active" data-sort="updated" data-icon="fa-clock">
        <i class="fas fa-clock"></i>
        <span>按更新时间</span>
    </div>
    <div class="search-sort-menu-item" data-sort="stars" data-icon="fa-fire">
        <i class="fas fa-fire"></i>
        <span>按热度（星标）</span>
    </div>
    <div class="search-sort-menu-item" data-sort="forks" data-icon="fa-code-branch">
        <i class="fas fa-code-branch"></i>
        <span>按复刻数</span>
    </div>
    <div class="search-sort-menu-item" data-sort="score" data-icon="fa-search">
        <i class="fas fa-search"></i>
        <span>按匹配度</span>
    </div>
</div>

    
    <script>
       // ==================== 配置模块 ====================
const Config = {
    // 文本文件扩展名列表
    textFileExtensions: ['txt', 'js', 'jsx', 'ts', 'tsx', 'html', 'css', 'scss', 'less', 'json', 'xml', 'yml', 'yaml', 'md', 'ini', 'conf', 'cfg', 'env', 'gitignore', 'log', 'sh', 'bash', 'zsh', 'py', 'java', 'c', 'cpp', 'h', 'hpp', 'cs', 'go', 'rs', 'swift', 'kt', 'dart', 'lua', 'rb', 'pl', 'r', 'm', 'php'],
    // Monaco Editor语言映射
    languageMapping: {
        'js': 'javascript',
        'jsx': 'javascript',
        'ts': 'typescript',
        'tsx': 'typescript',
        'html': 'html',
        'css': 'css',
        'scss': 'scss',
        'less': 'less',
        'json': 'json',
        'xml': 'xml',
        'yml': 'yaml',
        'yaml': 'yaml',
        'md': 'markdown',
        'sh': 'shell',
        'bash': 'shell',
        'zsh': 'shell',
        'py': 'python',
        'java': 'java',
        'c': 'c',
        'cpp': 'cpp',
        'h': 'c',
        'hpp': 'cpp',
        'cs': 'csharp',
        'go': 'go',
        'rs': 'rust',
        'swift': 'swift',
        'kt': 'kotlin',
        'dart': 'dart',
        'lua': 'lua',
        'rb': 'ruby',
        'pl': 'perl',
        'r': 'r',
        'm': 'matlab',
        'php': 'php'
    },
    // 文件类型图标映射
    fileTypeIcons: {
        // 工作流文件
        yml: 'fas fa-gears workflow-icon',
        yaml: 'fas fa-gears workflow-icon',
        // 压缩文件
        zip: 'fas fa-file-archive archive-icon',
        rar: 'fas fa-file-archive archive-icon',
        '7z': 'fas fa-file-archive archive-icon',
        tar: 'fas fa-file-archive archive-icon',
        gz: 'fas fa-file-archive archive-icon',
        bz2: 'fas fa-file-archive archive-icon',
        xz: 'fas fa-file-archive archive-icon',
        lz: 'fas fa-file-archive archive-icon',
        dmg: 'fas fa-file-archive archive-icon',
        iso: 'fas fa-file-archive archive-icon',
        
        // 可执行文件
        exe: 'fas fa-file-code exe-icon',
        msi: 'fas fa-file-code exe-icon',
        app: 'fas fa-file-code exe-icon',
        apk: 'fas fa-file-code exe-icon',
        deb: 'fas fa-file-code exe-icon',
        rpm: 'fas fa-file-code exe-icon',
        bat: 'fas fa-file-code exe-icon',
        cmd: 'fas fa-file-code exe-icon',
        
        // 图片
        png: 'fas fa-file-image image-icon',
        jpg: 'fas fa-file-image image-icon',
        jpeg: 'fas fa-file-image image-icon',
        gif: 'fas fa-file-image image-icon',
        svg: 'fas fa-file-image image-icon',
        webp: 'fas fa-file-image image-icon',
        ico: 'fas fa-file-image image-icon',
        bmp: 'fas fa-file-image image-icon',
        tiff: 'fas fa-file-image image-icon',
        psd: 'fas fa-file-image image-icon',
        ai: 'fas fa-file-image image-icon',
        
        // 代码文件
        css: 'fas fa-file-code code-icon',
        scss: 'fas fa-file-code code-icon',
        less: 'fas fa-file-code code-icon',
        js: 'fas fa-file-code code-icon',
        jsx: 'fas fa-file-code code-icon',
        ts: 'fas fa-file-code code-icon',
        tsx: 'fas fa-file-code code-icon',
        json: 'fas fa-file-code code-icon',
        html: 'fas fa-file-code code-icon',
        htm: 'fas fa-file-code code-icon',
        xml: 'fas fa-file-code code-icon',
        yml: 'fas fa-file-code code-icon',
        yaml: 'fas fa-file-code code-icon',
        php: 'fas fa-file-code code-icon',
        py: 'fas fa-file-code code-icon',
        java: 'fas fa-file-code code-icon',
        c: 'fas fa-file-code code-icon',
        cpp: 'fas fa-file-code code-icon',
        h: 'fas fa-file-code code-icon',
        hpp: 'fas fa-file-code code-icon',
        cs: 'fas fa-file-code code-icon',
        go: 'fas fa-file-code code-icon',
        rs: 'fas fa-file-code code-icon',
        sh: 'fas fa-file-code code-icon',
        bash: 'fas fa-file-code code-icon',
        zsh: 'fas fa-file-code code-icon',
        swift: 'fas fa-file-code code-icon',
        kt: 'fas fa-file-code code-icon',
        dart: 'fas fa-file-code code-icon',
        lua: 'fas fa-file-code code-icon',
        rb: 'fas fa-file-code code-icon',
        pl: 'fas fa-file-code code-icon',
        r: 'fas fa-file-code code-icon',
        m: 'fas fa-file-code code-icon',
        
        // 文本文件
        txt: 'fas fa-file-alt text-icon',
        md: 'fas fa-file-alt text-icon',
        markdown: 'fas fa-file-alt text-icon',
        log: 'fas fa-file-alt text-icon',
        rtf: 'fas fa-file-alt text-icon',
        
        // 文档
        pdf: 'fas fa-file-pdf text-red-500',
        doc: 'fas fa-file-word text-blue-600',
        docx: 'fas fa-file-word text-blue-600',
        xls: 'fas fa-file-excel text-green-600',
        xlsx: 'fas fa-file-excel text-green-600',
        ppt: 'fas fa-file-powerpoint text-orange-600',
        pptx: 'fas fa-file-powerpoint text-orange-600',
        csv: 'fas fa-file-csv text-green-600',
        odt: 'fas fa-file-word text-blue-600',
        ods: 'fas fa-file-excel text-green-600',
        odp: 'fas fa-file-powerpoint text-orange-600',
        
        // 数据库
        sql: 'fas fa-database text-blue-500',
        db: 'fas fa-database text-blue-500',
        sqlite: 'fas fa-database text-blue-500',
        mdb: 'fas fa-database text-blue-500',
        
        // 配置
        ini: 'fas fa-cog text-gray-500',
        cfg: 'fas fa-cog text-gray-500',
        conf: 'fas fa-cog text-gray-500',
        gitignore: 'fas fa-code-branch text-gray-500',
        env: 'fas fa-key text-yellow-500',
        
        // 字体
        ttf: 'fas fa-font text-purple-500',
        otf: 'fas fa-font text-purple-500',
        woff: 'fas fa-font text-purple-500',
        woff2: 'fas fa-font text-purple-500',
        
        // 视频
        mp4: 'fas fa-file-video text-red-400',
        mov: 'fas fa-file-video text-red-400',
        avi: 'fas fa-file-video text-red-400',
        mkv: 'fas fa-file-video text-red-400',
        flv: 'fas fa-file-video text-red-400',
        wmv: 'fas fa-file-video text-red-400',
        
        // 音频
        mp3: 'fas fa-file-audio text-blue-400',
        wav: 'fas fa-file-audio text-blue-400',
        ogg: 'fas fa-file-audio text-blue-400',
        flac: 'fas fa-file-audio text-blue-400',
        aac: 'fas fa-file-audio text-blue-400',
        
        // 其他
        lock: 'fas fa-lock text-gray-500',
        license: 'fas fa-file-signature text-gray-500',
        dockerfile: 'fab fa-docker text-blue-400',
        makefile: 'fas fa-file-code code-icon',
        procfile: 'fas fa-file-code code-icon',
    },
    // 统一图标映射（与文件类型图标风格保持一致）
    repoStatsIcons: {
        stars: 'fas fa-star text-yellow-500', 
        forks: 'fas fa-code-branch text-purple-500' 
    }
};


// ==================== 工具函数 ====================

// 辅助函数：将文件读取为Base64
function readFileAsBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            const arrayBuffer = reader.result;
            const binaryString = Array.from(new Uint8Array(arrayBuffer))
                .map(b => String.fromCharCode(b))
                .join('');
            resolve(btoa(binaryString));
        };
        reader.onerror = () => reject(new Error('文件读取失败'));
        reader.readAsArrayBuffer(file);
    });
}

// 辅助函数：检查文件是否存在并返回SHA
async function getFileShaIfExists(filePath) {
    try {
        const response = await fetch(
            `https://api.github.com/repos/${StateManager.currentRepo}/contents/${filePath}`,
            {
                headers: {
                    'Authorization': `token ${StateManager.githubToken}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Cache-Control': 'no-cache'
                }
            }
        );
        
        if (response.ok) {
            const data = await response.json();
            return data.sha;
        } else if (response.status === 404) {
            return null;
        } else {
            const errorData = await response.json();
            throw new Error(errorData.message || '检查文件状态失败');
        }
    } catch (error) {
        console.error('获取SHA错误:', error);
        throw error;
    }
}

// 辅助函数：编码GitHub路径
function encodeGitHubPath(path) {
    return path.split('/').map(encodeURIComponent).join('/');
}

// 辅助函数：检查文件是否存在并返回SHA（简化版）
async function getFileShaIfExistsSimple(filePath) {
    try {
        const response = await fetch(
            `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
            {
                headers: {
                    'Authorization': `token ${StateManager.githubToken}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            }
        );
        
        if (response.ok) {
            const data = await response.json();
            return data.sha;
        }
        return null;
    } catch (error) {
        return null;
    }
}

// 辅助函数：将文件读取为Base64（简化版
function readFileAsBase64Simple(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            // 直接转换整个结果为base64
            const base64 = btoa(reader.result);
            resolve(base64);
        };
        reader.onerror = () => reject(new Error('文件读取失败'));
        reader.readAsBinaryString(file); 
    });
}

// ==================== 状态管理模块 ====================
const StateManager = {
    currentRepo: '',
    currentPath: '',
    currentFiles: [],
    githubToken: '',
    fileToDelete: null,
    selectedFiles: new Set(),
    contextMenuTarget: null,
    currentUser: null,
    buildTimer: null,
    buildStatus: null,
    pagesEnabledMap: new Map(),
    directoryCache: new Map(),
    currentSearchQuery: null,
    searchResultCache: null,
    isSearchContextMenu: false,
    
    // 编辑器相关状态
    editor: null,
    currentEditingFile: null,
    monacoInitialized: false,
    monacoLoadAttempted: false,
    monacoLoadPromise: null,
    
    // 搜索排序相关新增状态
    currentSearchSort: 'updated', // 默认排序：按更新时间
    sortIconMap: { // 排序图标映射
        'updated': 'fa-clock',
        'stars': 'fa-fire', // 热度→火焰图标
        'forks': 'fa-code-branch',
        'score': 'fa-search'
    },
    
    // 状态操作方法
    resetSelection() {
        this.selectedFiles.clear();
        this.updateSelectedCount();
    },
    updateSelectedCount() {
        const selectedCount = document.getElementById('selected-count');
        if (selectedCount) {
            selectedCount.textContent = this.selectedFiles.size;
        }
    },
    setCurrentRepo(repo) {
        this.currentRepo = repo;
    },
    setCurrentPath(path) {
        this.currentPath = path;
    },
    setCurrentFiles(files) {
        this.currentFiles = files;
    },
    setToken(token) {
        if (token && token.length === 40) {
            this.githubToken = token;
            localStorage.setItem('github_token', token);
            console.log('Token 已保存到本地存储');
        }
    },
    clearToken() {
        this.githubToken = '';
        localStorage.removeItem('github_token');
        console.log('Token 已从本地存储清除');
    },
    
    addSelectedFile(file) {
        const fileKey = file.path || `${StateManager.currentPath ? StateManager.currentPath + '/' : ''}${file.name}`;
        let exists = false;
        for (let selectedFile of this.selectedFiles) {
            const selectedKey = selectedFile.path || `${StateManager.currentPath ? StateManager.currentPath + '/' : ''}${selectedFile.name}`;
            if (selectedKey === fileKey) {
                exists = true;
                break;
            }
        }
        if (!exists) {
            this.selectedFiles.add(file);
            this.updateSelectedCount();
        }
    },
    removeSelectedFile(file) {
        const fileKey = file.path || `${StateManager.currentPath ? StateManager.currentPath + '/' : ''}${file.name}`;
        for (let selectedFile of this.selectedFiles) {
            const selectedKey = selectedFile.path || `${StateManager.currentPath ? StateManager.currentPath + '/' : ''}${selectedFile.name}`;
            if (selectedKey === fileKey) {
                this.selectedFiles.delete(selectedFile);
                break;
            }
        }
        this.updateSelectedCount();
    },
    clearSelectedFiles() {
        this.selectedFiles.clear();
        this.updateSelectedCount();
    },
    
    // 缓存目录数据
    cacheDirectory(repo, path, files) {
        const cacheKey = path ? `${repo}/${path}` : repo;
        this.directoryCache.set(cacheKey, {
            files: [...files],
            timestamp: Date.now(),
            isSearch: this.currentSearchQuery ? true : false,
            searchQuery: this.currentSearchQuery
        });
    },
    
    // 获取缓存目录数据
    getCachedDirectory(repo, path) {
        const cacheKey = path ? `${repo}/${path}` : repo;
        const cacheData = this.directoryCache.get(cacheKey);
        if (!cacheData) return null;
        
        // 延长缓存时间到30分钟
        const cacheExpireTime = 30 * 60 * 1000; // 30分钟
        if (Date.now() - cacheData.timestamp > cacheExpireTime) {
            this.directoryCache.delete(cacheKey);
            return null;
        }
        
        return [...cacheData.files];
    },
    
    // 增强搜索缓存
    getCachedSearchResults(query, page = 1) {
        if (this.searchResultCache && 
            this.searchResultCache.query === query && 
            this.searchResultCache.currentPage === page) {
            
            const cacheExpireTime = 30 * 60 * 1000; // 30分钟
            if (Date.now() - this.searchResultCache.timestamp > cacheExpireTime) {
                this.searchResultCache = null;
                return null;
            }
            
            return this.searchResultCache;
        }
        return null;
    },
    
    // 清除目录缓存
    clearDirectoryCache(repo, path) {
        if (repo && path) {
            const cacheKey = `${repo}/${path}`;
            this.directoryCache.delete(cacheKey);
        } else if (repo) {
            const keysToDelete = [];
            for (let key of this.directoryCache.keys()) {
                if (key.startsWith(repo + '/') || key === repo) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => this.directoryCache.delete(key));
        } else {
            this.directoryCache.clear();
        }
    },
    
    // 搜索排序状态操作（新增完整方法）
    setSearchSort(sortType) {
        this.currentSearchSort = sortType;
        // 切换右侧图标
        const sortBtn = document.getElementById('search-sort-btn');
        if (sortBtn) {
            const iconClass = this.sortIconMap[sortType] || 'fa-clock';
            // 移除原有图标类
            const iconElement = sortBtn.querySelector('i');
            if (iconElement) {
                iconElement.className = '';
                iconElement.className = `fas ${iconClass}`;
            }
        }
        // 高亮当前选中项
        document.querySelectorAll('.search-sort-menu-item').forEach(item => {
            item.classList.toggle('active', item.dataset.sort === sortType);
        });
    },
    getSearchSort() {
        return this.currentSearchSort;
    }
};

// ==================== DOM 管理模块 ====================
const DOMManager = {
    // DOM 元素引用
    elements: {},
    // 初始化DOM元素引用
    init() {
        this.elements = {
            // 认证界面
            authScreen: document.getElementById('auth-screen'),
            authBtn: document.getElementById('auth-btn'),
            authBtnText: document.getElementById('auth-btn-text'),
            authSpinner: document.getElementById('auth-spinner'),
            githubTokenInput: document.getElementById('github-token'),
            tokenError: document.getElementById('token-error'),
            // 主界面
            mainScreen: document.getElementById('main-screen'),
            currentPath: document.getElementById('current-path'),
            fileList: document.getElementById('file-list'),
            loading: document.getElementById('loading'),
            emptyState: document.getElementById('empty-state'),
            // 工具栏按钮
            refreshBtn: document.getElementById('refresh-btn'),
            newRepoBtn: document.getElementById('new-repo-btn'),
            forkRepoBtn: document.getElementById('fork-repo-btn'),
            newFolderBtn: document.getElementById('new-folder-btn'),
            uploadBtn: document.getElementById('upload-btn'),
            selectBtn: document.getElementById('select-btn'),
            staticSiteBtn: document.getElementById('static-site-btn'),
            // 用户菜单
            userMenuBtn: document.getElementById('user-menu-btn'),
            userMenuContent: document.getElementById('user-menu-content'),
            username: document.getElementById('username'),
            logoutBtn: document.getElementById('logout-btn'),
            // 批量操作
            batchToolbar: document.getElementById('batch-toolbar'),
            selectedCount: document.getElementById('selected-count'),
            batchDownloadBtn: document.getElementById('batch-download-btn'),
            batchDeleteBtn: document.getElementById('batch-delete-btn'),
            batchCancelBtn: document.getElementById('batch-cancel-btn'),
            // 编辑器
            editorContainer: document.getElementById('editor-container'),
            editorSaveBtn: document.getElementById('editor-save-btn'),
            editorCloseBtn: document.getElementById('editor-close-btn'),
            editorFilename: document.getElementById('editor-filename'),
            editorFileSize: document.getElementById('editor-file-size'),
            editorLanguage: document.getElementById('editor-language'),
            // 移动设备工具栏
            mobileSaveBtn: document.getElementById('mobile-save-btn'),
            mobileCloseBtn: document.getElementById('mobile-close-btn'),
            mobileUndoBtn: document.getElementById('mobile-undo-btn'),
            mobileRedoBtn: document.getElementById('mobile-redo-btn'),
            mobileSearchBtn: document.getElementById('mobile-search-btn'),
            // 对话框
            confirmDialog: document.getElementById('confirm-dialog'),
            confirmTitle: document.getElementById('confirm-title'),
            confirmMessage: document.getElementById('confirm-message'),
            confirmYes: document.getElementById('confirm-yes'),
            confirmNo: document.getElementById('confirm-no'),
            // 新建文件夹对话框
            newFolderDialog: document.getElementById('new-folder-dialog'),
            newFolderName: document.getElementById('new-folder-name'),
            newFolderCreate: document.getElementById('new-folder-create'),
            newFolderCancel: document.getElementById('new-folder-cancel'),
            // 新建仓库对话框
            newRepoDialog: document.getElementById('new-repo-dialog'),
            newRepoName: document.getElementById('new-repo-name'),
            newRepoDesc: document.getElementById('new-repo-desc'),
            newRepoPrivate: document.getElementById('new-repo-private'),
            newRepoCreate: document.getElementById('new-repo-create'),
            newRepoCancel: document.getElementById('new-repo-cancel'),
            // 复刻仓库对话框
            forkRepoDialog: document.getElementById('fork-repo-dialog'),
            forkRepoUrl: document.getElementById('fork-repo-url'),
            forkRepoConfirm: document.getElementById('fork-repo-confirm'),
            forkRepoCancel: document.getElementById('fork-repo-cancel'),
            // 上传文件对话框
            uploadDialog: document.getElementById('upload-dialog'),
            fileInput: document.getElementById('file-input'),
            uploadFile: document.getElementById('upload-file'),
            uploadCancel: document.getElementById('upload-cancel'),
            // 部署网站对话框
            staticSiteDialog: document.getElementById('static-site-dialog'),
            pagesBranch: document.getElementById('pages-branch'),
            pagesFolder: document.getElementById('pages-folder'),
            pagesStatus: document.getElementById('pages-status'),
            pagesUrl: document.getElementById('pages-url'),
            staticSiteEnable: document.getElementById('static-site-enable'),
            staticSiteCancel: document.getElementById('static-site-cancel'),
            // 搜索相关元素（删除不存在的searchContainer、repoSearchInput、clearSearchBtn）
            searchRepoBtn: document.getElementById('search-repo-btn'),
            searchOverlay: document.getElementById('search-overlay'),
            searchOverlayClose: document.getElementById('search-overlay-close'),
            searchOverlayInput: document.getElementById('search-overlay-input'),
            searchHistory: document.getElementById('search-history'),
            // 上下文菜单
            contextMenu: document.getElementById('context-menu'),
            contextOpen: document.getElementById('context-open'),
            contextDownload: document.getElementById('context-download'),
            contextRename: document.getElementById('context-rename'),
            contextCopyLink: document.getElementById('context-copy-link'),
            contextCopyProxyLink: document.getElementById('context-copy-proxy-link'),
            contextDelete: document.getElementById('context-delete'),
            contextEnablePages: document.getElementById('context-enable-pages'),
            contextBuildApp: document.getElementById('context-build-app'),
            contextDownloadSource: document.getElementById('context-download-source'),
            contextCopyRepoLink: document.getElementById('context-copy-repo-link'),
            contextCopySiteLink: document.getElementById('context-copy-site-link'),
            contextRenameRepo: document.getElementById('context-rename-repo'),
            // 搜索结果上下文菜单
            searchContextMenu: document.getElementById('search-context-menu'),
            searchContextFork: document.getElementById('search-context-fork'),
            searchContextCopyLink: document.getElementById('search-context-copy-link'),
            searchContextVisit: document.getElementById('search-context-visit'),
            // 搜索文件上下文菜单
            searchFileContextMenu: document.getElementById('search-file-context-menu'),
            searchFileOpen: document.getElementById('search-file-open'),
            searchFileDownload: document.getElementById('search-file-download'),
            searchFileCopyLink: document.getElementById('search-file-copy-link'),
            searchFileCopyProxyLink: document.getElementById('search-file-copy-proxy-link'),
            // 提示和状态
            toast: document.getElementById('toast'),
            buildStatus: document.getElementById('build-status'),
            buildIcon: document.getElementById('build-icon'),
            buildMessage: document.getElementById('build-message'),
            progressBar: document.getElementById('progress-bar'),
            progressText: document.getElementById('progress-text'),
            closeBuildStatus: document.getElementById('close-build-status'),
            // 版本列表相关元素
            releasesSection: document.getElementById('releases-section'),
            releasesLoading: document.getElementById('releases-loading'),
            releasesList: document.getElementById('releases-list'),
            releasesEmpty: document.getElementById('releases-empty'),
            refreshReleasesBtn: document.getElementById('refresh-releases-btn')
        };
    },
    // 显示/隐藏方法
    show(element) {
        if (element) element.classList.remove('hidden');
    },
    hide(element) {
        if (element) element.classList.add('hidden');
    },
    toggle(element) {
        if (element) element.classList.toggle('hidden');
    },
    // 特定元素的显示/隐藏
    showMainScreen() {
        this.hide(this.elements.authScreen);
        this.show(this.elements.mainScreen);
    },
    showAuthScreen() {
        this.hide(this.elements.mainScreen);
        this.show(this.elements.authScreen);
    },
    showLoading() {
        this.hide(this.elements.fileList);
        this.hide(this.elements.emptyState);
        this.show(this.elements.loading);
    },
    showFileList() {
        this.hide(this.elements.loading);
        this.hide(this.elements.emptyState);
        this.show(this.elements.fileList);
    },
    showEmptyState() {
        this.hide(this.elements.fileList);
        this.hide(this.elements.loading);
        this.show(this.elements.emptyState);
    },
    showBatchToolbar() {
        if (this.elements.batchToolbar) {
            this.elements.batchToolbar.classList.add('visible');
        }
    },
    hideBatchToolbar() {
        if (this.elements.batchToolbar) {
            this.elements.batchToolbar.classList.remove('visible');
        }
    },
    // 更新按钮状态
    updateButtonVisibility(isRepoView) {
        const {
            uploadBtn, newFolderBtn, selectBtn,
            staticSiteBtn, newRepoBtn, forkRepoBtn
        } = this.elements;
        if (isRepoView) {
            this.hide(uploadBtn);
            this.hide(newFolderBtn);
            this.hide(selectBtn);
            this.hide(staticSiteBtn);
            this.show(newRepoBtn);
            this.show(forkRepoBtn);
        } else {
            this.show(uploadBtn);
            this.show(newFolderBtn);
            this.show(selectBtn);
            this.hide(newRepoBtn);
            this.hide(forkRepoBtn);
        }
    },
    // 显示/隐藏搜索框（适配已删除的元素）
    toggleSearchBox(show) {
        // 因searchContainer已删除，直接调用SearchManager打开搜索层
        if (show) {
            SearchManager.openSearchOverlay();
        } else {
            SearchManager.closeSearchOverlay();
            // 清除搜索后回到仓库列表
            if (StateManager.currentRepo === '' && StateManager.currentPath === '') {
                NavigationManager.loadRepositories();
            }
        }
    },
    // 渲染版本列表 - 最终修复版本
    renderReleases(releases) {
        const { releasesSection, releasesList, releasesEmpty, releasesLoading } = this.elements;
        
        // 先隐藏加载状态
        this.hide(releasesLoading);
        
        // 修复逻辑：只要有版本数据就显示版本区域
        if (releases && releases.length > 0) {
            // 有版本时显示版本区域和列表
            this.show(releasesSection);
            this.show(releasesList);
            this.hide(releasesEmpty);
            
            releasesList.innerHTML = '';
            
            releases.forEach(release => {
                const releaseItem = document.createElement('div');
                releaseItem.className = 'glass p-4 mb-3';
                
                const releaseHeader = document.createElement('div');
                releaseHeader.className = 'flex items-center justify-between mb-2';
                
                const tagName = document.createElement('h3');
                tagName.className = 'font-bold text-lg text-blue-600';
                tagName.textContent = release.tag_name;
                
                const releaseDate = document.createElement('span');
                releaseDate.className = 'text-sm text-gray-500';
                releaseDate.textContent = new Date(release.published_at).toLocaleString();
                
                releaseHeader.appendChild(tagName);
                releaseHeader.appendChild(releaseDate);
                
                const releaseTitle = document.createElement('div');
                releaseTitle.className = 'font-medium mb-2';
                releaseTitle.textContent = release.name || '无标题版本';
                
                const releaseDesc = document.createElement('div');
                releaseDesc.className = 'text-sm text-gray-600 mb-3';
                releaseDesc.innerHTML = release.body ? release.body.replace(/\n/g, '<br>') : '无描述';
                
                const releaseActions = document.createElement('div');
                releaseActions.className = 'flex gap-2';
                
                const downloadBtn = document.createElement('a');
                downloadBtn.href = release.zipball_url;
                downloadBtn.target = '_blank';
                downloadBtn.className = 'glass-btn px-3 py-1 text-sm flex items-center';
                downloadBtn.innerHTML = '<i class="fas fa-download mr-1"></i> 下载源码';
                
                const visitBtn = document.createElement('a');
                visitBtn.href = release.html_url;
                visitBtn.target = '_blank';
                visitBtn.className = 'glass-btn px-3 py-1 text-sm flex items-center';
                visitBtn.innerHTML = '<i class="fas fa-external-link-alt mr-1"></i> 查看详情';
                
                releaseActions.appendChild(downloadBtn);
                releaseActions.appendChild(visitBtn);
                
                releaseItem.appendChild(releaseHeader);
                releaseItem.appendChild(releaseTitle);
                releaseItem.appendChild(releaseDesc);
                releaseItem.appendChild(releaseActions);
                
                releasesList.appendChild(releaseItem);
            });
        } else {
            // 无版本时隐藏整个版本区域
            this.hide(releasesSection);
        }
    }
};

// ==================== API 服务模块 ====================
const APIService = {
    baseURL: 'https://api.github.com',
    graphqlURL: 'https://api.github.com/graphql',
    
    // 通用请求方法
    async request(url, options = {}) {
        const token = StateManager.githubToken;
        if (!token) throw new Error('未找到认证令牌');
        const defaultOptions = {
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                ...options.headers
            }
        };
        const response = await fetch(url, { ...defaultOptions, ...options });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `请求失败: ${response.status}`);
        }
        return response;
    },
    
    // GraphQL 请求
    async graphql(query) {
        const token = StateManager.githubToken;
        if (!token) throw new Error('未找到认证令牌');
        const response = await fetch(this.graphqlURL, {
            method: 'POST',
            headers: {
                'Authorization': `bearer ${token}`, 
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({ query })
        });
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.message || `GraphQL请求失败: ${response.status}`);
        }
        return response.json();
    },
    
    // 通用请求头生成方法
    getAuthHeaders() {
        return {
            'Authorization': `token ${StateManager.githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
        };
    },
    
    // 启用 GitHub Pages
    async enableGitHubPages(owner, repo, branch, path) {
        const response = await fetch(
            `${this.baseURL}/repos/${owner}/${repo}/pages`,
            {
                method: 'POST',
                headers: this.getAuthHeaders(),
                body: JSON.stringify({
                    source: {
                        branch: branch,
                        path: path
                    }
                })
            }
        );
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `启用 Pages 失败: ${response.status}`);
        }
        return response.json();
    },
    
    // 用户认证
    async verifyToken(token) {
        const response = await fetch(`${this.baseURL}/user`, {
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || '认证失败');
        }
        
        return response.json();
    },
    
    // 获取仓库列表（修改后的版本）
    async getRepositories() {
        const query = `
            query {
                viewer {
                    repositories(first: 100, ownerAffiliations: [OWNER], orderBy: {field: NAME, direction: ASC}) {
                        nodes {
                            name
                            owner {
                                login
                            }
                            isPrivate
                            description
                            updatedAt
                        }
                    }
                }
            }
        `;
        
        const data = await this.graphql(query);
        
        // 并行检查每个仓库的Pages状态和版本状态
        const reposWithStatus = await Promise.all(
            data.data.viewer.repositories.nodes.map(async repo => {
                try {
                    // 检查Pages状态
                    const pagesStatus = await this.getPagesStatus(repo.owner.login, repo.name);
                    const pagesEnabled = pagesStatus && (pagesStatus.status === 'built' || pagesStatus.status === 'building');
                    
                    // 检查版本状态
                    const hasReleases = await this.checkRepositoryReleases(repo.owner.login, repo.name);
                    
                    // 更新状态映射
                    StateManager.pagesEnabledMap.set(`${repo.owner.login}/${repo.name}`, pagesEnabled);
                    
                    return {
                        name: repo.name,
                        type: 'repo',
                        path: `${repo.owner.login}/${repo.name}`,
                        private: repo.isPrivate,
                        description: repo.description,
                        updatedAt: repo.updatedAt,
                        pagesEnabled: pagesEnabled,
                        hasReleases: hasReleases
                    };
                } catch (error) {
                    console.error(`检查仓库 ${repo.name} 状态失败:`, error);
                    return {
                        name: repo.name,
                        type: 'repo',
                        path: `${repo.owner.login}/${repo.name}`,
                        private: repo.isPrivate,
                        description: repo.description,
                        updatedAt: repo.updatedAt,
                        pagesEnabled: false,
                        hasReleases: false
                    };
                }
            })
        );
        return reposWithStatus;
    },
    
    // 检查仓库版本状态的方法
    async checkRepositoryReleases(owner, repo) {
        try {
            const response = await this.request(
                `${this.baseURL}/repos/${owner}/${repo}/releases?per_page=1`,
                { method: 'GET' }
            );
            const releases = await response.json();
            return releases.length > 0;
        } catch (error) {
            console.error(`检查仓库 ${owner}/${repo} 版本失败:`, error);
            return false;
        }
    },
    
    // 获取仓库内容 - 修复版本
async getRepositoryContents(repo, path = '') {
    try {
        const [owner, repoName] = repo.split('/');
        
        // 构建 GraphQL 查询
        const query = `
            query {
                repository(owner: "${owner}", name: "${repoName}") {
                    object(expression: "HEAD:${path}") {
                        ... on Tree {
                            entries {
                                name
                                type
                                object {
                                    ... on Blob {
                                        byteSize
                                    }
                                }
                            }
                        }
                    }
                }
            }
        `;
        
        const data = await this.graphql(query);
        
        // 添加空值检查
        if (!data.data || !data.data.repository || !data.data.repository.object) {
            console.warn(`仓库内容为空: ${repo}/${path}`);
            return [];
        }
        
        // 安全地处理数据
        const entries = data.data.repository.object.entries || [];
        
        return entries.map(entry => ({
            name: entry.name,
            type: entry.type === 'tree' ? 'dir' : 'file',
            size: entry.object?.byteSize || 0,
            path: path ? `${path}/${entry.name}` : entry.name,
            download_url: entry.type === 'blob' ? 
                `https://raw.githubusercontent.com/${repo}/HEAD/${path ? path + '/' : ''}${entry.name}` : null
        }));
        
    } catch (error) {
        console.error('获取仓库内容错误:', error);
        
        // 如果是空目录或路径不存在，返回空数组而不是抛出错误
        if (error.message.includes('not exist') || error.message.includes('not found')) {
            console.warn(`路径不存在或为空目录: ${repo}/${path}`);
            return [];
        }
        
        throw error;
    }
},
    
    // 获取文件内容 
    async getFileContent(repo, path) {
        try {
            const response = await fetch(
                `${this.baseURL}/repos/${repo}/contents/${encodeURIComponent(path)}`,
                {
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                }
            );
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || '获取文件内容失败');
            }
            
            const data = await response.json();
            
            // 解码base64内容
            const decodedContent = this.decodeBase64Content(data.content);
            
            return {
                content: decodedContent,
                sha: data.sha
            };
        } catch (error) {
            console.error('获取文件内容错误:', error);
            throw error;
        }
    },
    
    // 创建文件
    async createFile(repo, path, content, message) {
        const base64Content = btoa(unescape(encodeURIComponent(content)));
        
        const response = await this.request(`${this.baseURL}/repos/${repo}/contents/${path}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message,
                content: base64Content
            })
        });
        return response.json();
    },
    
    // 更新文件 
    async updateFile(repo, path, content, sha, message) {
        const base64Content = btoa(unescape(encodeURIComponent(content)));
        
        const response = await fetch(
            `${this.baseURL}/repos/${repo}/contents/${encodeURIComponent(path)}`,
            {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${StateManager.githubToken}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message,
                    content: base64Content,
                    sha
                })
            }
        );
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `更新失败: ${response.status}`);
        }
        return response.json();
    },
    
    // 改进的Base64解码方法
    decodeBase64Content(base64) {
        try {
            const binaryString = atob(base64);
            
            // 尝试UTF-8解码
            try {
                return decodeURIComponent(escape(binaryString));
            } catch (e) {
                // 如果UTF-8解码失败，返回原始内容
                return binaryString;
            }
        } catch (error) {
            console.error('Base64解码失败:', error);
            // 尝试直接返回
            try {
                return atob(base64);
            } catch (e2) {
                throw new Error('文件内容解码失败');
            }
        }
    },
    
    // 删除文件 
    async deleteFile(repo, path, sha, message) {
        const response = await this.request(`${this.baseURL}/repos/${repo}/contents/${encodeURIComponent(path)}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message,
                sha
            })
        });
        return response.json();
    },
    
    // 创建仓库
    async createRepository(name, description, isPrivate) {
        const response = await this.request(`${this.baseURL}/user/repos`, {
            method: 'POST',
            body: JSON.stringify({
                name,
                description: description || '',
                private: !!isPrivate,
                auto_init: true
            })
        });
        return response.json();
    },
    
    // 删除仓库
    async deleteRepository(owner, repo) {
        const response = await this.request(`${this.baseURL}/repos/${owner}/${repo}`, {
            method: 'DELETE'
        });
        return response.status === 204;
    },
    
    // 复刻仓库
    async forkRepository(owner, repo) {
        const response = await this.request(`${this.baseURL}/repos/${owner}/${repo}/forks`, {
            method: 'POST'
        });
        return response.json();
    },
    
    // 获取仓库信息
    async getRepositoryInfo(owner, repo) {
        const response = await this.request(`${this.baseURL}/repos/${owner}/${repo}`);
        return response.json();
    },
    
    // 禁用 GitHub Pages
    async disableGitHubPages(owner, repo) {
        const response = await this.request(`${this.baseURL}/repos/${owner}/${repo}/pages`, {
            method: 'DELETE'
        });
        return response.status === 204;
    },
    
    // 获取 Pages 状态
    async getPagesStatus(owner, repo) {
        const response = await this.request(`${this.baseURL}/repos/${owner}/${repo}/pages`);
        return response.json();
    },
    
    // 触发工作流
    async triggerWorkflow(owner, repo, workflowFileName, branch) {
        const response = await this.request(
            `${this.baseURL}/repos/${owner}/${repo}/actions/workflows/${workflowFileName}/dispatches`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    ref: branch
                })
            }
        );
        return response.status === 204;
    },
    
    // 获取工作流运行状态
    async getWorkflowRuns(owner, repo) {
        const response = await this.request(`${this.baseURL}/repos/${owner}/${repo}/actions/runs`);
        return response.json();
    },
    
    // 工具函数
    decodeBase64Utf8(base64) {
        try {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return new TextDecoder('utf-8').decode(bytes);
        } catch (e) {
            try {
                return decodeURIComponent(escape(atob(base64)));
            } catch (e2) {
                console.error('Base64解码失败:', e2);
                return atob(base64);
            }
        }
    },
    
    // 搜索GitHub仓库（支持分页）
async searchRepositories(query, page = 1) {
    const sortMap = {
        'updated': 'updated',
        'stars': 'stars',
        'forks': 'forks',
        'score': 'score'
    };
    const sort = sortMap[StateManager.getSearchSort()] || 'updated';
    const order = sort === 'score' ? 'desc' : 'desc';
    
    const response = await this.request(
        `${this.baseURL}/search/repositories?q=${encodeURIComponent(query)}&per_page=100&page=${page}&sort=${sort}&order=${order}`,
        { method: 'GET' }
    );
    const data = await response.json();
    
    // 获取分页信息
    const linkHeader = response.headers.get('Link');
    let hasNextPage = false;
    let nextPage = null;
    
    if (linkHeader) {
        const links = linkHeader.split(',');
        links.forEach(link => {
            if (link.includes('rel="next"')) {
                hasNextPage = true;
                const match = link.match(/page=(\d+)/);
                if (match) nextPage = parseInt(match[1]);
            }
        });
    }
    
    // 并行检查每个仓库的Pages状态和版本状态
    const reposWithStatus = await Promise.all(
        data.items.map(async repo => {
            try {
                // 检查Pages状态
                const pagesStatus = await this.getPagesStatus(repo.owner.login, repo.name);
                const pagesEnabled = pagesStatus && (pagesStatus.status === 'built' || pagesStatus.status === 'building');
                
                // 检查版本状态
                const hasReleases = await this.checkRepositoryReleases(repo.owner.login, repo.name);
                
                return {
                    name: repo.name,
                    type: 'repo',
                    path: `${repo.owner.login}/${repo.name}`,
                    private: repo.private,
                    description: repo.description,
                    updatedAt: repo.updated_at,
                    stars: repo.stargazers_count,
                    forks: repo.forks_count,
                    pagesEnabled: pagesEnabled,
                    hasReleases: hasReleases
                };
            } catch (error) {
                console.error(`检查搜索结果仓库 ${repo.name} 状态失败:`, error);
                return {
                    name: repo.name,
                    type: 'repo',
                    path: `${repo.owner.login}/${repo.name}`,
                    private: repo.private,
                    description: repo.description,
                    updatedAt: repo.updated_at,
                    stars: repo.stargazers_count,
                    forks: repo.forks_count,
                    pagesEnabled: false,
                    hasReleases: false
                };
            }
        })
    );
    
    return {
        items: reposWithStatus,
        totalCount: data.total_count,
        hasNextPage: hasNextPage,
        nextPage: nextPage,
        currentPage: page
    };
},
    
    // 获取仓库发布版本
    async getRepositoryReleases(owner, repo) {
        const response = await this.request(
            `${this.baseURL}/repos/${owner}/${repo}/releases`,
            { method: 'GET' }
        );
        return response.json();
    }
};


// ==================== 搜索管理模块 ====================
const SearchManager = {
    currentSearchType: 'repositories',
    
    // 初始化搜索功能
    init() {
        this.bindEvents();
        this.loadSearchHistory();
        this.bindSearchTypeEvents();
        this.bindSortEvents();
    },
    
    // 绑定搜索相关事件
    bindEvents() {
        const { searchOverlay, searchOverlayClose, searchOverlayInput, searchHistory } = DOMManager.elements;
        
        // 关闭搜索遮罩层
        searchOverlayClose?.addEventListener('click', () => {
            this.closeSearchOverlay();
        });
        
        // 点击遮罩层空白处关闭
        searchOverlay?.addEventListener('click', (e) => {
            if (e.target === searchOverlay) {
                this.closeSearchOverlay();
            }
        });
        
        // 键盘事件：ESC关闭，Enter搜索
        searchOverlayInput?.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closeSearchOverlay();
            } else if (e.key === 'Enter') {
                const query = e.target.value.trim();
                if (query) {
                    this.doSearch(query);
                }
            }
        });
        
        // 输入框聚焦时显示搜索历史
        searchOverlayInput?.addEventListener('focus', () => {
            this.showSearchHistory();
        });
    },
    
    // 绑定搜索类型选择事件
    bindSearchTypeEvents() {
        const typeButtons = document.querySelectorAll('.search-type-btn');
        typeButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.setSearchType(btn.dataset.type);
            });
        });
    },
    
    // 绑定排序事件
    bindSortEvents() {
        const sortBtn = document.getElementById('search-sort-btn');
        const sortMenu = document.getElementById('search-sort-context-menu');
        
        sortBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            // 定位菜单到输入框下方左侧对齐
            const inputRect = document.getElementById('search-overlay-input').getBoundingClientRect();
            const menuWidth = sortMenu.offsetWidth || 160;
            sortMenu.style.left = `${inputRect.left}px`;
            sortMenu.style.top = `${inputRect.bottom + 8}px`;
            sortMenu.classList.add('visible');
        });
        
        // 排序菜单项点击
        document.querySelectorAll('.search-sort-menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const sortType = item.dataset.sort;
                StateManager.setSearchSort(sortType);
                sortMenu.classList.remove('visible');
                // 已有关键词则重新搜索
                const query = document.getElementById('search-overlay-input').value.trim();
                if (query && this.currentSearchType === 'repositories') {
                    this.doSearch(query);
                }
            });
        });
        
        // 点击其他地方关闭排序菜单
        document.addEventListener('click', () => {
            sortMenu.classList.remove('visible');
        });
    },
    
    // 设置搜索类型
    setSearchType(type) {
        this.currentSearchType = type;
        
        // 更新按钮状态
        document.querySelectorAll('.search-type-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.type === type);
        });
        
        // 更新搜索提示和占位符
        this.updateSearchHint();
        
        // 显示/隐藏排序按钮（仅仓库搜索显示排序）
        const sortBtn = document.getElementById('search-sort-btn');
        if (sortBtn) {
            sortBtn.style.display = type === 'repositories' ? 'flex' : 'none';
        }
        
        // 如果当前有搜索词，重新搜索
        const searchInput = document.getElementById('search-overlay-input');
        if (searchInput.value.trim()) {
            this.doSearch(searchInput.value.trim());
        }
    },
    
    // 更新搜索提示
    updateSearchHint() {
        const hintElement = document.getElementById('search-hint');
        const inputElement = document.getElementById('search-overlay-input');
        
        const hints = {
            'repositories': '搜索 GitHub 仓库',
            'code': '搜索代码片段',
            'issues': '搜索 Issues 和 Pull Requests',
            'users': '搜索用户和组织'
        };
        
        const placeholders = {
            'repositories': '搜索仓库名称、描述...',
            'code': '搜索代码片段、文件名...',
            'issues': '搜索 Issues 标题、内容...',
            'users': '搜索用户名、组织名...'
        };
        
        if (hintElement) {
            hintElement.textContent = hints[this.currentSearchType] || hints.repositories;
        }
        
        if (inputElement) {
            inputElement.placeholder = placeholders[this.currentSearchType] || placeholders.repositories;
        }
    },
    
    // 打开搜索遮罩层
    openSearchOverlay() {
        const { searchOverlay, searchOverlayInput } = DOMManager.elements;
        if (!searchOverlay || !searchOverlayInput) return;
        
        searchOverlay.classList.remove('hidden');
        
        // 延迟确保DOM更新
        setTimeout(() => {
            searchOverlayInput.focus();
            searchOverlayInput.select();
            this.updateSearchHint();
        }, 100);
    },
    
    // 关闭搜索遮罩层
    closeSearchOverlay() {
        const { searchOverlay, searchOverlayInput, searchHistory } = DOMManager.elements;
        if (!searchOverlay) return;
        
        searchOverlay.classList.add('hidden');
        if (searchOverlayInput) searchOverlayInput.value = '';
        if (searchHistory) searchHistory.classList.add('hidden');
    },
    
    // 执行搜索
    async doSearch(query) {
        this.saveSearchHistory(query);
        this.closeSearchOverlay();
        
        // 根据搜索类型调用不同的API
        switch (this.currentSearchType) {
            case 'repositories':
                await NavigationManager.loadSearchResults(query);
                break;
            case 'code':
                await this.searchCode(query);
                break;
            case 'issues':
                await this.searchIssues(query);
                break;
            case 'users':
                await this.searchUsers(query);
                break;
            default:
                await NavigationManager.loadSearchResults(query);
        }
    },
    
    // 搜索代码
    async searchCode(query) {
        try {
            DOMManager.showLoading();
            StateManager.setCurrentPath('');
            StateManager.setCurrentRepo('');
            StateManager.currentSearchQuery = query;
            
            NavigationManager.updateBreadcrumb([`代码搜索: "${query}"`]);
            DOMManager.updateButtonVisibility(true);
            
            const response = await APIService.request(
                `https://api.github.com/search/code?q=${encodeURIComponent(query)}&per_page=100`
            );
            const data = await response.json();
            
            const formattedResults = data.items.map(item => ({
                name: item.name,
                type: 'file',
                path: item.repository.full_name,
                repository: item.repository,
                html_url: item.html_url,
                download_url: item.download_url,
                size: item.size || 0,
                isSearchResult: true,
                searchType: 'code'
            }));
            
            StateManager.searchResultCache = {
                query,
                results: formattedResults,
                timestamp: Date.now(),
                type: 'code'
            };
            
            FileManager.renderFileList(formattedResults);
            
        } catch (error) {
            console.error('代码搜索失败:', error);
            ToastManager.show('代码搜索失败: ' + error.message);
            DOMManager.showEmptyState();
        }
    },
    
    // 搜索Issues
    async searchIssues(query) {
        try {
            DOMManager.showLoading();
            StateManager.setCurrentPath('');
            StateManager.setCurrentRepo('');
            StateManager.currentSearchQuery = query;
            
            NavigationManager.updateBreadcrumb([`Issues搜索: "${query}"`]);
            DOMManager.updateButtonVisibility(true);
            
            const response = await APIService.request(
                `https://api.github.com/search/issues?q=${encodeURIComponent(query)}&per_page=100`
            );
            const data = await response.json();
            
            const formattedResults = data.items.map(item => ({
                name: `#${item.number} ${item.title}`,
                type: 'issue',
                path: item.repository_url.replace('https://api.github.com/repos/', ''),
                repository: item.repository_url.replace('https://api.github.com/repos/', ''),
                html_url: item.html_url,
                state: item.state,
                user: item.user,
                created_at: item.created_at,
                updated_at: item.updated_at,
                isSearchResult: true,
                searchType: 'issues'
            }));
            
            StateManager.searchResultCache = {
                query,
                results: formattedResults,
                timestamp: Date.now(),
                type: 'issues'
            };
            
            FileManager.renderFileList(formattedResults);
            
        } catch (error) {
            console.error('Issues搜索失败:', error);
            ToastManager.show('Issues搜索失败: ' + error.message);
            DOMManager.showEmptyState();
        }
    },
    
    // 搜索用户
    async searchUsers(query) {
        try {
            DOMManager.showLoading();
            StateManager.setCurrentPath('');
            StateManager.setCurrentRepo('');
            StateManager.currentSearchQuery = query;
            
            NavigationManager.updateBreadcrumb([`用户搜索: "${query}"`]);
            DOMManager.updateButtonVisibility(true);
            
            const response = await APIService.request(
                `https://api.github.com/search/users?q=${encodeURIComponent(query)}&per_page=100`
            );
            const data = await response.json();
            
            const formattedResults = data.items.map(user => ({
                name: user.login,
                type: 'user',
                avatar_url: user.avatar_url,
                html_url: user.html_url,
                isSearchResult: true,
                searchType: 'users'
            }));
            
            StateManager.searchResultCache = {
                query,
                results: formattedResults,
                timestamp: Date.now(),
                type: 'users'
            };
            
            FileManager.renderFileList(formattedResults);
            
        } catch (error) {
            console.error('用户搜索失败:', error);
            ToastManager.show('用户搜索失败: ' + error.message);
            DOMManager.showEmptyState();
        }
    },
    
    // 以下为原有的搜索历史管理方法
    loadSearchHistory() {
        try {
            const history = localStorage.getItem('github_search_history');
            return history ? JSON.parse(history) : [];
        } catch (error) {
            console.error('加载搜索历史失败:', error);
            return [];
        }
    },
    
    saveSearchHistory(query) {
        try {
            let history = this.loadSearchHistory();
            // 移除重复项
            history = history.filter(item => item !== query);
            // 添加到开头
            history.unshift(query);
            // 限制数量
            if (history.length > 10) history.pop();
            localStorage.setItem('github_search_history', JSON.stringify(history));
        } catch (error) {
            console.error('保存搜索历史失败:', error);
        }
    },
    
    deleteSearchHistory(query) {
        try {
            let history = this.loadSearchHistory();
            history = history.filter(item => item !== query);
            localStorage.setItem('github_search_history', JSON.stringify(history));
            this.showSearchHistory();
        } catch (error) {
            console.error('删除搜索历史失败:', error);
        }
    },
    
    showSearchHistory() {
        const { searchHistory, searchOverlayInput } = DOMManager.elements;
        if (!searchHistory) return;
        
        const history = this.loadSearchHistory();
        
        if (history.length === 0) {
            searchHistory.classList.add('hidden');
            return;
        }
        
        searchHistory.classList.remove('hidden');
        searchHistory.innerHTML = '';
        
        history.forEach(item => {
            const historyItem = document.createElement('div');
            historyItem.className = 'search-history-item';
            
            const textEl = document.createElement('div');
            textEl.className = 'search-history-text';
            textEl.textContent = item;
            textEl.addEventListener('click', () => {
                if (searchOverlayInput) {
                    searchOverlayInput.value = item;
                    this.doSearch(item);
                }
            });
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'search-history-delete';
            deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteSearchHistory(item);
            });
            
            historyItem.appendChild(textEl);
            historyItem.appendChild(deleteBtn);
            searchHistory.appendChild(historyItem);
        });
    }
};

// ==================== 文件管理模块 ====================
const FileManager = {
    // 渲染文件列表
    renderFileList(items) {
        const fileListElement = DOMManager.elements.fileList;
        if (!fileListElement) return;
        fileListElement.innerHTML = '';
        DOMManager.showFileList();
        if (items.length === 0) {
            DOMManager.showEmptyState();
            return;
        }
        items.forEach(item => {
            const fileItem = this.createFileItem(item);
            fileListElement.appendChild(fileItem);
        });
    },
    
    // 创建文件项
    createFileItem(item) {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item p-4 flex items-center';
        fileItem.dataset.name = item.name;
        fileItem.dataset.type = item.type;
        fileItem.dataset.path = item.path || '';
        
        // 右键菜单：严格区分
        fileItem.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation(); // 关键：阻止事件冒泡到document
            
            const isSearchResultPage = !StateManager.currentRepo && StateManager.currentSearchQuery;
            const isSearchRepoFileList = StateManager.currentRepo && StateManager.currentSearchQuery;
            
            if (isSearchResultPage && item.type === 'repo') {
                ContextMenuManager.showSearchContextMenu(e, item);
            } else if (isSearchRepoFileList) {
                ContextMenuManager.show(e, item);
            } else {
                ContextMenuManager.show(e, item);
            }
        });
        
        // 点击事件
        fileItem.addEventListener('click', (e) => {
            this.handleFileClick(e, item);
        });
        
        // 搜索结果长按菜单（仓库列表）
        const isSearchResultPage = !StateManager.currentRepo && StateManager.currentPath === '';
        if (isSearchResultPage && item.type === 'repo') {
            let longPressTimer;
            fileItem.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    longPressTimer = setTimeout(() => {
                        ContextMenuManager.showSearchContextMenu(e, item);
                    }, 500);
                }
            });
            
            fileItem.addEventListener('mouseup', () => {
                clearTimeout(longPressTimer);
            });
            
            fileItem.addEventListener('mouseleave', () => {
                clearTimeout(longPressTimer);
            });
        }
        
        // 搜索结果仓库文件列表长按菜单
        const isSearchRepoFileList = StateManager.currentRepo && item.type !== 'repo';
        if (isSearchRepoFileList) {
            let longPressTimer;
            fileItem.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    longPressTimer = setTimeout(() => {
                        ContextMenuManager.showSearchFileContextMenu(e, item);
                    }, 500);
                }
            });
            
            fileItem.addEventListener('mouseup', () => {
                clearTimeout(longPressTimer);
            });
            
            fileItem.addEventListener('mouseleave', () => {
                clearTimeout(longPressTimer);
            });
        }
        
        // 创建文件内容
        const icon = this.createFileIcon(item);
        const infoContainer = this.createFileInfo(item);
        fileItem.appendChild(icon);
        fileItem.appendChild(infoContainer);
        return fileItem;
    },
    
    // 创建文件图标
    createFileIcon(item) {
        const icon = document.createElement('i');
        
        if (item.type === 'dir') {
            icon.className = 'file-icon fas fa-folder folder-icon';
        } else if (item.type === 'repo') {
            icon.className = 'file-icon fab fa-github text-gray-700';
        } else {
            const extension = item.name.split('.').pop().toLowerCase();
            const iconClass = Config.fileTypeIcons[extension] || 'fas fa-file text-gray-400';
            icon.className = `file-icon ${iconClass}`;
        }
        return icon;
    },
    
// 修复文件信息创建方法
createFileInfo(item) {
    const infoContainer = document.createElement('div');
    infoContainer.className = 'file-info-container';
    
    if (item.type === 'repo') {
        // 仓库类型：使用新的布局，标签在名称后面
        const firstLine = document.createElement('div');
        firstLine.className = 'file-info-first-line';
        
        // 仓库名称 - 在标签前面
        const name = document.createElement('div');
        name.className = 'file-name';
        name.textContent = item.name;
        name.title = item.name;
        
        // 标签容器 - 移到名称后面
const tagsContainer = document.createElement('div');
tagsContainer.className = 'repo-tags';

if (item.pagesEnabled) {
    const siteTag = document.createElement('div');
    siteTag.className = 'repo-tag-icon tag-site';
    siteTag.innerHTML = '<i class="fas fa-globe"></i>';
    siteTag.title = '已启用GitHub Pages';
    tagsContainer.appendChild(siteTag);
}

if (item.hasReleases) {
    const releaseTag = document.createElement('div');
    releaseTag.className = 'repo-tag-icon tag-release';
    releaseTag.innerHTML = '<i class="fas fa-box"></i>';
    releaseTag.title = '有发布版本';
    tagsContainer.appendChild(releaseTag);
}
                        
        // 将名称和标签容器添加到第一行（名称在前，标签在后）
        firstLine.appendChild(name);
        firstLine.appendChild(tagsContainer);
        
        const secondLine = document.createElement('div');
        secondLine.className = 'file-meta';
        
        let secondLineText = item.private ? '私有仓库' : '公开仓库';
        if (item.description) {
            // 限制描述长度，防止过长
            const maxDescLength = 80;
            const description = item.description.length > maxDescLength 
                ? item.description.substring(0, maxDescLength) + '...' 
                : item.description;
            secondLineText += ' • ' + description;
        }
        secondLine.textContent = secondLineText;
        secondLine.title = secondLineText;
        
        const thirdLine = document.createElement('div');
        thirdLine.className = 'file-stats';
        
        const statsContainer = document.createElement('div');
        statsContainer.className = 'stats';
        
        if (item.stars !== undefined) {
            const starStat = document.createElement('span');
            starStat.className = 'star-stat';
            starStat.innerHTML = `<i class="fas fa-star text-yellow-500 text-xs"></i>${this.formatNumber(item.stars)}`;
            statsContainer.appendChild(starStat);
        }
        
        if (item.forks !== undefined) {
            const forkStat = document.createElement('span');
            forkStat.className = 'fork-stat';
            forkStat.innerHTML = `<i class="fas fa-code-branch text-purple-500 text-xs"></i>${this.formatNumber(item.forks)}`;
            statsContainer.appendChild(forkStat);
        }
        
        const updateTime = document.createElement('div');
        updateTime.className = 'update-time';
        if (item.updatedAt) {
            updateTime.textContent = this.formatRelativeTime(item.updatedAt);
        }
        updateTime.title = item.updatedAt ? new Date(item.updatedAt).toLocaleString() : '';
        
        thirdLine.appendChild(statsContainer);
        thirdLine.appendChild(updateTime);
        
        infoContainer.appendChild(firstLine);
        infoContainer.appendChild(secondLine);
        infoContainer.appendChild(thirdLine);
        
    } else if (item.type === 'file') {
        // 文件类型布局
        const mainInfo = document.createElement('div');
        mainInfo.className = 'file-info-main flex items-center justify-between mb-1';
        
        const nameContainer = document.createElement('div');
        nameContainer.className = 'flex items-center gap-2 min-w-0 flex-1';
        
        const name = document.createElement('div');
        name.className = 'file-name truncate';
        name.textContent = item.name;
        name.title = item.name;
        nameContainer.appendChild(name);
        
        mainInfo.appendChild(nameContainer);
        
        const meta = document.createElement('div');
        meta.className = 'file-meta';
        meta.textContent = this.formatFileSize(item.size);
        
        infoContainer.appendChild(mainInfo);
        infoContainer.appendChild(meta);
        
    } else {
        // 文件夹类型布局
        const mainInfo = document.createElement('div');
        mainInfo.className = 'file-info-main flex items-center justify-between mb-1';
        
        const nameContainer = document.createElement('div');
        nameContainer.className = 'flex items-center gap-2 min-w-0 flex-1';
        
        const name = document.createElement('div');
        name.className = 'file-name truncate';
        name.textContent = item.name;
        name.title = item.name;
        nameContainer.appendChild(name);
        
        mainInfo.appendChild(nameContainer);
        
        const meta = document.createElement('div');
        meta.className = 'file-meta';
        meta.textContent = '文件夹';
        
        infoContainer.appendChild(mainInfo);
        infoContainer.appendChild(meta);
    }
    
    return infoContainer;
},

// 添加数字格式化方法
formatNumber(num) {
    if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'k';
    }
    return num.toString();
},
    // 添加相对时间格式化方法
    formatRelativeTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffWeeks = Math.floor(diffDays / 7);
        const diffMonths = Math.floor(diffDays / 30);
        
        if (diffMins < 1) {
            return '刚刚';
        } else if (diffMins < 60) {
            return `${diffMins}分钟前`;
        } else if (diffHours < 24) {
            return `${diffHours}小时前`;
        } else if (diffDays < 7) {
            return `${diffDays}天前`;
        } else if (diffWeeks < 4) {
            return `${diffWeeks}周前`;
        } else if (diffMonths < 12) {
            return `${diffMonths}月前`;
        } else {
            return date.toLocaleDateString('zh-CN', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }
    },
    
    // 创建操作链接
    createActionLink(text, onClick) {
        const link = document.createElement('a');
        link.href = '#';
        link.className = 'text-blue-500 hover:underline ml-2 text-xs';
        link.textContent = text;
        link.addEventListener('click', (e) => {
            e.stopPropagation();
            onClick();
        });
        return link;
    },
    
    // 处理文件点击
    handleFileClick(e, item) {
        e.preventDefault();
        e.stopPropagation();
        
        // 首先检查是否在选择模式
        if (SelectionManager.isInSelectMode()) {
            // 在选择模式下，处理文件选择
            SelectionManager.handleFileSelection(e.currentTarget, item);
            return;
        }
        
        // 正常点击行为
        if (item.type === 'dir') {
            NavigationManager.loadRepositoryContents(
                StateManager.currentRepo, 
                `${StateManager.currentPath ? StateManager.currentPath + '/' : ''}${item.name}`
            );
        } else if (item.type === 'repo') {
            // 搜索结果中的仓库点击导航
            NavigationManager.loadRepositoryContents(item.path);
        } else if (item.type === 'file') {
            this.handleFileOpen(item);
        }
    },
    
    // 处理文件打开
    handleFileOpen(item) {
        const fileExt = item.name.split('.').pop().toLowerCase();
        
        // 文本文件 - 在编辑器中打开
        if (Config.textFileExtensions.includes(fileExt)) {
            EditorManager.openFileInEditor(item);
        } 
        // 图片文件 - 直接预览
        else if (['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'bmp'].includes(fileExt)) {
            this.showImagePreview(item);
        }
        // PDF文件 - 在新窗口打开
        else if (fileExt === 'pdf') {
            window.open(item.download_url, '_blank');
        }
        // 其他文件 - 直接下载
        else {
            this.downloadFile(item);
        }
    },
    
    // 切换文件选择
    toggleFileSelection(fileItem, fileInfo) {
        if (fileItem.classList.contains('selected')) {
            fileItem.classList.remove('selected');
            StateManager.removeSelectedFile(fileInfo);
        } else {
            fileItem.classList.add('selected');
            StateManager.addSelectedFile(fileInfo);
        }
        // 如果没有选中文件，退出选择模式
        if (StateManager.selectedFiles.size === 0) {
            SelectionManager.exitSelectMode();
        }
    },
    
    // 下载文件 - 修复版本
async downloadFile(file) {
    if (file.type !== 'file' || !file.download_url) {
        ToastManager.show('无法下载此文件');
        return;
    }
    
    try {
        ToastManager.show(`正在下载 ${file.name}...`);
        
        console.log('开始下载文件:', file.name, 'URL:', file.download_url);
        
        // 添加超时控制
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超时
        
        const response = await fetch(file.download_url, {
            signal: controller.signal,
            headers: {
                // 添加必要的请求头
                'Accept': '*/*',
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`下载失败: HTTP ${response.status} ${response.statusText}`);
        }
        
        // 检查文件大小
        const contentLength = response.headers.get('content-length');
        const fileSize = contentLength ? parseInt(contentLength) : 0;
        
        if (fileSize > 100 * 1024 * 1024) { // 100MB限制
            throw new Error('文件过大，建议使用GitHub原生下载');
        }
        
        const blob = await response.blob();
        
        // 检查blob是否有效
        if (!blob || blob.size === 0) {
            throw new Error('下载的文件为空');
        }
        
        console.log('文件下载完成，大小:', blob.size, 'bytes');
        
        // 创建下载链接
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = file.name;
        link.style.display = 'none';
        
        // 添加到DOM并触发点击
        document.body.appendChild(link);
        link.click();
        
        // 清理资源
        setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }, 100);
        
        ToastManager.show(`已下载 ${file.name} (${this.formatFileSize(blob.size)})`);
        
    } catch (error) {
        console.error('下载失败:', error);
        
        let errorMessage = '下载失败: ';
        
        if (error.name === 'AbortError') {
            errorMessage += '下载超时，请检查网络连接';
        } else if (error.message.includes('Failed to fetch')) {
            errorMessage += '网络错误，请检查网络连接';
        } else if (error.message.includes('HTTP 403')) {
            errorMessage += '访问被拒绝，可能是GitHub限制';
        } else if (error.message.includes('HTTP 404')) {
            errorMessage += '文件不存在';
        } else {
            errorMessage += error.message;
        }
        
        ToastManager.show(errorMessage);
        
        // 尝试备用下载方法
        this.fallbackDownload(file);
    }
},

// 备用下载方法
async fallbackDownload(file) {
    try {
        ToastManager.show('尝试备用下载方法...');
        
        // 方法1: 直接打开新窗口
        window.open(file.download_url, '_blank');
        
        // 方法2: 使用GitHub原始内容API
        setTimeout(() => {
            const rawUrl = file.download_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            const fallbackLink = document.createElement('a');
            fallbackLink.href = rawUrl;
            fallbackLink.target = '_blank';
            fallbackLink.style.display = 'none';
            document.body.appendChild(fallbackLink);
            fallbackLink.click();
            setTimeout(() => {
                document.body.removeChild(fallbackLink);
            }, 100);
        }, 1000);
        
    } catch (fallbackError) {
        console.error('备用下载也失败:', fallbackError);
        ToastManager.show('所有下载方法都失败，请手动访问文件页面下载');
    }
},
    
    // 显示图片预览
    showImagePreview(item) {
        // 创建预览容器
        const previewContainer = document.createElement('div');
        previewContainer.className = 'image-preview-container';
        previewContainer.innerHTML = `
            <div class="image-preview-content">
                <div class="image-preview-header">
                    <div class="image-preview-title">${item.name}</div>
                    <button class="image-preview-close" title="关闭">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="image-preview-body">
                    <div class="loading-indicator">
                        <i class="fas fa-spinner fa-spin"></i> 加载中...
                    </div>
                </div>
                <div class="image-preview-footer">
                    <div class="background-toggle">
                        <button class="btn-bg-light" title="浅色背景">
                            <i class="fas fa-sun"></i>
                        </button>
                        <button class="btn-bg-dark" title="深色网格背景">
                            <i class="fas fa-moon"></i>
                        </button>
                        <button class="btn-bg-grid" title="浅色网格背景">
                            <i class="fas fa-border-all"></i>
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        // 添加到页面
        document.body.appendChild(previewContainer);
        document.body.style.overflow = 'hidden';
        
        // 获取图片容器元素
        const imgBody = previewContainer.querySelector('.image-preview-body');
        
        // 使用API获取图片内容
        this.fetchImageContent(item).then(blobUrl => {
            // 移除加载指示器
            imgBody.innerHTML = '';
            
            // 创建图片元素
            const img = document.createElement('img');
            img.src = blobUrl;
            img.alt = item.name;
            img.loading = 'lazy';
            imgBody.appendChild(img);
            
            // 根据图片类型设置初始背景
            const ext = item.name.split('.').pop().toLowerCase();
            const isTransparent = ['png', 'gif', 'svg', 'webp'].includes(ext);
            
            if (isTransparent) {
                imgBody.classList.add('checkerboard-dark-bg');
            }
            
            // 背景切换功能
            previewContainer.querySelector('.btn-bg-light').addEventListener('click', () => {
                imgBody.className = 'image-preview-body light-bg';
            });
            
            previewContainer.querySelector('.btn-bg-dark').addEventListener('click', () => {
                imgBody.className = 'image-preview-body checkerboard-dark-bg';
            });
            
            previewContainer.querySelector('.btn-bg-grid').addEventListener('click', () => {
                imgBody.className = 'image-preview-body checkerboard-bg';
            });
            
            // 图片加载错误处理
            img.onerror = () => {
                imgBody.innerHTML = '<div class="text-red-500">图片加载失败</div>';
                URL.revokeObjectURL(blobUrl);
            };
            
            // 图片加载成功后释放内存
            img.onload = () => {
                setTimeout(() => URL.revokeObjectURL(blobUrl), 1000);
            };
        }).catch(error => {
            console.error('获取图片失败:', error);
            imgBody.innerHTML = '<div class="text-red-500">图片加载失败: ' + error.message + '</div>';
        });
        
        // 关闭预览的函数
        const closePreview = () => {
            document.body.removeChild(previewContainer);
            document.body.style.overflow = '';
        };
        
        // 添加关闭事件
        previewContainer.querySelector('.image-preview-close').addEventListener('click', closePreview);
        
        // ESC键关闭
        document.addEventListener('keydown', function escClose(e) {
            if (e.key === 'Escape') {
                closePreview();
                document.removeEventListener('keydown', escClose);
            }
        });
    },
    
    // 获取图片内容
    async fetchImageContent(fileInfo) {
        const apiUrl = `https://api.github.com/repos/${StateManager.currentRepo}/contents/${
            StateManager.currentPath ? encodeURIComponent(StateManager.currentPath) + '/' : ''
        }${encodeURIComponent(fileInfo.name)}`;
        
        const response = await fetch(apiUrl, {
            headers: {
                'Authorization': `token ${StateManager.githubToken}`,
                'Accept': 'application/vnd.github.v3.raw'
            }
        });
        
        if (!response.ok) {
            throw new Error('获取图片内容失败: ' + response.status);
        }
        
        const blob = await response.blob();
        
        // 检查文件扩展名，如果是svg，则修正MIME类型
        const ext = fileInfo.name.split('.').pop().toLowerCase();
        if (ext === 'svg') {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const svgString = reader.result;
                    const correctedBlob = new Blob([svgString], { type: 'image/svg+xml' });
                    resolve(URL.createObjectURL(correctedBlob));
                };
                reader.readAsText(blob);
            });
        }
        
        return URL.createObjectURL(blob);
    },
    
    // 工具函数
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },
    
    formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    }
};


// ==================== 仓库头像显示增强模块 ====================
const RepoAvatarEnhancer = {
    // 缓存头像URL，避免重复请求
    avatarCache: new Map(),
    
    init() {
        // 重写FileManager.createFileItem方法，注入头像显示逻辑
        this.overrideFileItemCreation();
        // 监听搜索结果加载完成事件（通过定时器检测DOM变化）
        this.monitorSearchResults();
    },
    
    // 重写文件项创建方法
    overrideFileItemCreation() {
        const originalCreateFileItem = FileManager.createFileItem;
        FileManager.createFileItem = function(item) {
            const fileItem = originalCreateFileItem.call(this, item);
            
            // 仅对仓库类型添加头像
            if (item.type === 'repo') {
                RepoAvatarEnhancer.addRepoAvatar(fileItem, item);
            }
            
            return fileItem;
        };
    },
    
    // 为仓库项添加所有者头像
    async addRepoAvatar(fileItem, repoItem) {
        // 获取仓库所有者（从path解析：owner/repo）
        const [owner] = repoItem.path.split('/');
        let avatarUrl = this.avatarCache.get(owner);
        
        // 缓存未命中时请求GitHub用户头像
        if (!avatarUrl) {
            try {
                const response = await fetch(`https://api.github.com/users/${owner}`, {
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (response.ok) {
                    const userData = await response.json();
                    avatarUrl = userData.avatar_url;
                    RepoAvatarEnhancer.avatarCache.set(owner, avatarUrl);
                } else {
                    // 默认头像（GitHub风格灰色头像）
                    avatarUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(owner)}&background=ddd&color=333&size=40`;
                }
            } catch (error) {
                // 异常时使用字母头像
                avatarUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(owner)}&background=ddd&color=333&size=40`;
            }
        }
        
        // 替换原有GitHub图标为头像
        const iconElement = fileItem.querySelector('.file-icon.fab.fa-github');
        if (iconElement) {
            iconElement.outerHTML = `
                <img class="file-icon rounded-full w-10 h-10 object-cover border-2 border-white shadow-sm" 
                     src="${avatarUrl}" alt="${owner} 的头像" 
                     style="margin-right: 12px; filter: drop-shadow(1px 1px 2px rgba(0, 0, 0, 0.1));">
            `;
        }
    },
    
    // 监听搜索结果DOM变化，为搜索结果仓库添加头像
    monitorSearchResults() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                if (mutation.addedNodes.length > 0) {
                    mutation.addedNodes.forEach(node => {
                        if (node.classList?.contains('file-item') && node.dataset.type === 'repo') {
                            const repoPath = node.dataset.path;
                            if (repoPath) {
                                this.addRepoAvatar(node, {
                                    type: 'repo',
                                    path: repoPath
                                });
                            }
                        }
                    });
                }
            });
        });
        
        // 监听文件列表DOM变化
        const fileList = document.getElementById('file-list');
        if (fileList) {
            observer.observe(fileList, { childList: true, subtree: true });
        }
    }
};
// 初始化头像增强模块（在App初始化后执行）
document.addEventListener('DOMContentLoaded', () => {
    // 确保在App初始化完成后执行
    setTimeout(() => {
        RepoAvatarEnhancer.init();
    }, 300);
});


// ==================== 自动刷新管理模块 - 修复版 ====================
const AutoRefreshManager = {
    // 刷新当前视图 - 增强版
    refreshCurrentView(forceRefresh = false) {
        console.log('刷新当前视图，强制模式:', forceRefresh);
        
        // 强制清除所有相关缓存
        if (forceRefresh) {
            this.clearAllRelatedCaches();
        }
        
        if (StateManager.currentRepo && StateManager.currentPath !== undefined) {
            // 刷新仓库内容，不使用缓存
            NavigationManager.loadRepositoryContents(StateManager.currentRepo, StateManager.currentPath, false);
        } else if (StateManager.currentSearchQuery) {
            // 刷新搜索结果，不使用缓存
            NavigationManager.loadSearchResults(StateManager.currentSearchQuery, 1, false);
        } else {
            // 刷新仓库列表，不使用缓存
            NavigationManager.loadRepositories(false);
        }
    },
    
    // 操作后刷新（带延迟）- 增强版
    refreshAfterOperation(delay = 800, forceRefresh = true) {
        console.log(`计划在 ${delay}ms 后刷新，强制模式: ${forceRefresh}`);
        setTimeout(() => {
            this.refreshCurrentView(forceRefresh);
        }, delay);
    },
    
    // 清除所有相关缓存 - 新增方法
    clearAllRelatedCaches() {
        console.log('清除所有相关缓存');
        
        // 清除当前目录缓存
        if (StateManager.currentRepo) {
            StateManager.clearDirectoryCache(StateManager.currentRepo, StateManager.currentPath);
            
            // 同时清除父目录缓存（用于面包屑导航更新）
            if (StateManager.currentPath) {
                const pathParts = StateManager.currentPath.split('/');
                for (let i = pathParts.length; i > 0; i--) {
                    const parentPath = pathParts.slice(0, i).join('/');
                    StateManager.clearDirectoryCache(StateManager.currentRepo, parentPath);
                }
            }
            
            // 清除仓库根目录缓存
            StateManager.clearDirectoryCache(StateManager.currentRepo, '');
        }
        
        // 清除仓库列表缓存
        StateManager.clearDirectoryCache('repositories', '');
        
        // 清除搜索缓存
        StateManager.searchResultCache = null;
        
        // 清除 Pages 状态缓存
        StateManager.pagesEnabledMap.clear();
        
        console.log('缓存清理完成');
    },
    
    // 刷新并清除缓存
    refreshWithCacheClear() {
        this.clearAllRelatedCaches();
        this.refreshAfterOperation(500, false);
    },
    
    // 特定操作后的刷新策略
    refreshAfterFileOperation() {
        this.clearAllRelatedCaches();
        this.refreshAfterOperation(1000, false);
    },
    
    refreshAfterRepoOperation() {
        this.clearAllRelatedCaches();
        // 仓库操作需要更长时间等待GitHub处理
        this.refreshAfterOperation(1500, false);
    }
};

// ==================== 导航管理模块 - 修复完整版 ====================
const NavigationManager = {
    // 加载仓库列表 - 修复版本
    async loadRepositories(useCache = true) {
        // 清除搜索相关状态，但保留缓存
        StateManager.currentSearchQuery = null;
        StateManager.searchResultCache = null;
        
        DOMManager.showLoading();
        StateManager.setCurrentPath('');
        StateManager.setCurrentRepo('');
        this.updateBreadcrumb([]);
        DOMManager.updateButtonVisibility(true);
        DOMManager.hide(DOMManager.elements.releasesSection);
        
        this.pushHistoryState('repositories', { type: 'repositories' });
        
        // 优先使用缓存
        if (useCache) {
            const cachedRepos = StateManager.getCachedDirectory('repositories', '');
            if (cachedRepos) {
                FileManager.renderFileList(cachedRepos);
                return;
            }
        }
        
        try {
            const repos = await APIService.getRepositories();
            StateManager.cacheDirectory('repositories', '', repos);
            FileManager.renderFileList(repos);
        } catch (error) {
            ToastManager.show('加载失败: ' + error.message);
            DOMManager.showEmptyState();
        }
    },
    
    // 加载仓库内容 - 修复版本
    async loadRepositoryContents(repo, path = '', useCache = true) {
        DOMManager.showLoading();
        StateManager.setCurrentRepo(repo);
        StateManager.setCurrentPath(path);
        DOMManager.updateButtonVisibility(false);
        
        // 修复：只在仓库根目录显示版本列表
        const isRepoRoot = path === '';
        if (isRepoRoot) {
            // 显示版本区域和加载状态
            DOMManager.show(DOMManager.elements.releasesSection);
            DOMManager.show(DOMManager.elements.releasesLoading);
            DOMManager.hide(DOMManager.elements.releasesList);
            DOMManager.hide(DOMManager.elements.releasesEmpty);
            
            // 异步加载版本列表
            const [owner, repoName] = repo.split('/');
            APIService.getRepositoryReleases(owner, repoName)
                .then(releases => {
                    DOMManager.renderReleases(releases);
                })
                .catch(error => {
                    console.error('加载版本列表失败:', error);
                    // 加载失败时隐藏版本区域
                    DOMManager.hide(DOMManager.elements.releasesSection);
                });
        } else {
            // 非根目录隐藏版本列表
            DOMManager.hide(DOMManager.elements.releasesSection);
        }
        
        const [owner, repoName] = repo.split('/');
        
        const pathParts = path ? path.split('/') : [];
        this.updateBreadcrumb([repo, ...pathParts]);
        
        const isFromSearch = StateManager.currentSearchQuery && StateManager.currentRepo === '';
        this.pushHistoryState('contents', { 
            repo, 
            path: path || '',
            isSearch: isFromSearch,
            query: StateManager.currentSearchQuery
        });
        
        // 优先使用缓存
        if (useCache) {
            const cachedFiles = StateManager.getCachedDirectory(repo, path);
            if (cachedFiles) {
                StateManager.setCurrentFiles(cachedFiles);
                const sortedContents = [...cachedFiles].sort((a, b) => {
                    if (a.type === b.type) {
                        return a.name.localeCompare(b.name);
                    }
                    return a.type === 'dir' ? -1 : 1;
                });
                FileManager.renderFileList(sortedContents);
                this.updateStaticSiteButton(cachedFiles, path);
                return;
            }
        }
        
        try {
            const contents = await APIService.getRepositoryContents(repo, path);
            StateManager.setCurrentFiles(contents);
            StateManager.cacheDirectory(repo, path, contents);
            
            const sortedContents = [...contents].sort((a, b) => {
                if (a.type === b.type) {
                    return a.name.localeCompare(b.name);
                }
                return a.type === 'dir' ? -1 : 1;
            });
            
            FileManager.renderFileList(sortedContents);
            this.updateStaticSiteButton(contents, path);
            
        } catch (error) {
            ToastManager.show('加载失败: ' + error.message);
            DOMManager.showEmptyState();
        }
    },
    
    // 推送历史状态 - 修复版本
    pushHistoryState(type, data) {
        const state = {
            type: type,
            data: data,
            timestamp: Date.now()
        };
        
        const title = this.getPageTitle(type, data);
        const url = this.createURL(type, data);
        
        const currentState = history.state;
        
        // 更精确的状态比较
        const isSameState = currentState && 
            currentState.type === type && 
            JSON.stringify(currentState.data) === JSON.stringify(data);
        
        if (isSameState) {
            return;
        }
        
        if (!currentState) {
            history.replaceState(state, title, url);
        } else {
            history.pushState(state, title, url);
        }
    },
    
    // 获取页面标题
    getPageTitle(type, data) {
        if (type === 'repositories') {
            return '我的仓库 - GitHub Mgr';
        } else if (type === 'contents') {
            const repoName = data.repo.split('/').pop();
            const pathInfo = data.path ? ` - ${data.path}` : '';
            return `${repoName}${pathInfo} - GitHub Mgr`;
        } else if (type === 'search') {
            return `搜索: ${data.query} - GitHub Mgr`;
        }
        return 'GitHub Mgr';
    },
    
    // 创建URL - 修复版本
    createURL(type, data) {
        const params = new URLSearchParams();
        
        if (type === 'repositories') {
            return window.location.pathname;
        } else if (type === 'contents') {
            params.set('repo', encodeURIComponent(data.repo));
            if (data.path) {
                params.set('path', encodeURIComponent(data.path));
            }
            if (data.isSearch) {
                params.set('isSearch', 'true');
            }
            if (data.query) {
                params.set('query', encodeURIComponent(data.query));
            }
            return `?${params.toString()}`;
        } else if (type === 'search') {
            params.set('search', encodeURIComponent(data.query));
            if (data.isSearchRepo) {
                params.set('isSearchRepo', 'true');
            }
            return `?${params.toString()}`;
        }
        return window.location.pathname;
    },
    
    // 处理历史回退 - 修复版本
    handlePopState(event) {
        if (event.state && event.state.type) {
            const { type, data } = event.state;
            console.log('处理历史回退:', type, data);
            
            // 根据状态类型决定是否使用缓存
            let useCache = true;
            
            // 如果是搜索结果到仓库的导航，使用缓存
            if (type === 'contents' && data.isSearch) {
                useCache = true;
                // 恢复搜索状态
                StateManager.currentSearchQuery = data.query;
            } 
            // 如果是搜索结果的导航，使用缓存
            else if (type === 'search') {
                useCache = true;
                StateManager.currentSearchQuery = data.query;
            }
            // 其他情况也尽量使用缓存
            else {
                useCache = true;
            }
            
            this.navigateToState(type, data, useCache);
        } else {
            const state = this.parseURL();
            this.navigateToState(state.type, state.data, true);
        }
    },
    
    // 解析URL - 修复版本
    parseURL() {
        const urlParams = new URLSearchParams(window.location.search);
        const repo = urlParams.get('repo');
        const path = urlParams.get('path');
        const search = urlParams.get('search');
        const isSearch = urlParams.get('isSearch') === 'true';
        const isSearchRepo = urlParams.get('isSearchRepo') === 'true';
        const query = urlParams.get('query');
        
        if (search) {
            return { 
                type: 'search', 
                data: { 
                    query: decodeURIComponent(search),
                    isSearchRepo: isSearchRepo
                } 
            };
        } else if (repo) {
            return { 
                type: 'contents', 
                data: { 
                    repo: decodeURIComponent(repo), 
                    path: path ? decodeURIComponent(path) : '',
                    isSearch: isSearch,
                    query: query ? decodeURIComponent(query) : null
                } 
            };
        }
        return { type: 'repositories', data: {} };
    },
    
    // 导航到状态 - 修复版本
    navigateToState(type, data, useCache = true) {
        console.log('导航到状态:', type, data, '使用缓存:', useCache);
        
        if (type === 'repositories') {
            // 保留搜索查询状态，但不显示搜索结果
            this.loadRepositories(useCache);
        } else if (type === 'contents') {
            // 恢复搜索状态
            if (data.isSearch && data.query) {
                StateManager.currentSearchQuery = data.query;
            }
            
            this.loadRepositoryContents(data.repo, data.path, useCache);
        } else if (type === 'search') {
            StateManager.currentSearchQuery = data.query;
            this.loadSearchResults(data.query, 1, useCache);
        } else {
            this.loadRepositories(useCache);
        }
    },
    
    // 加载搜索结果 - 修复版本
    async loadSearchResults(query, page = 1, useCache = true) {
        // 如果使用缓存且查询相同，直接使用缓存结果
        if (useCache && StateManager.searchResultCache && 
            StateManager.searchResultCache.query === query && 
            StateManager.searchResultCache.currentPage === page) {
            
            DOMManager.showFileList();
            StateManager.setCurrentFiles(StateManager.searchResultCache.results);
            FileManager.renderFileList(StateManager.searchResultCache.results);
            this.showSearchStats(StateManager.searchResultCache.totalCount, 
                               StateManager.searchResultCache.results.length);
            return;
        }
        
        DOMManager.showLoading();
        StateManager.setCurrentPath('');
        StateManager.setCurrentRepo('');
        StateManager.currentSearchQuery = query;
        
        this.updateBreadcrumb([`搜索结果: "${query}"`]);
        DOMManager.updateButtonVisibility(true);
        DOMManager.hide(DOMManager.elements.releasesSection);
        
        this.pushHistoryState('search', { 
            query,
            isSearchRepo: StateManager.currentRepo ? true : false
        });
        
        try {
            const searchResult = await APIService.searchRepositories(query, page);
            
            let formattedResults;
            if (page === 1) {
                // 第一页，创建新的结果集
                formattedResults = searchResult.items.map(repo => ({
                    ...repo,
                    type: 'repo',
                    isSearchResult: true
                }));
                
                StateManager.searchResultCache = {
                    query,
                    results: formattedResults,
                    totalCount: searchResult.totalCount,
                    hasNextPage: searchResult.hasNextPage,
                    nextPage: searchResult.nextPage,
                    currentPage: page,
                    timestamp: Date.now()
                };
            } else {
                // 后续页面，追加到现有结果
                const newResults = searchResult.items.map(repo => ({
                    ...repo,
                    type: 'repo',
                    isSearchResult: true
                }));
                
                formattedResults = [...StateManager.searchResultCache.results, ...newResults];
                
                StateManager.searchResultCache.results = formattedResults;
                StateManager.searchResultCache.hasNextPage = searchResult.hasNextPage;
                StateManager.searchResultCache.nextPage = searchResult.nextPage;
                StateManager.searchResultCache.currentPage = page;
            }
            
            StateManager.setCurrentFiles(formattedResults);
            FileManager.renderFileList(formattedResults);
            
            // 显示搜索统计信息
            this.showSearchStats(searchResult.totalCount, formattedResults.length);
            
        } catch (error) {
            console.error('搜索失败:', error);
            ToastManager.show('搜索失败: ' + error.message);
            DOMManager.showEmptyState();
        }
    },

    // 显示搜索统计信息
    showSearchStats(totalCount, displayedCount) {
        // 移除现有的统计信息
        const existingStats = document.getElementById('search-stats');
        if (existingStats) {
            existingStats.remove();
        }
        
        // 移除可能存在的加载更多按钮
        const existingLoadMore = document.getElementById('load-more-results');
        if (existingLoadMore) {
            existingLoadMore.remove();
        }
        
        if (totalCount > 0) {
            const statsElement = document.createElement('div');
            statsElement.id = 'search-stats';
            statsElement.className = 'text-center text-sm text-gray-500 mt-4 p-3 glass rounded-lg';
            
            if (totalCount > displayedCount) {
                statsElement.innerHTML = `
                    <div>显示 <strong>${displayedCount}</strong> 个结果（共 <strong>${totalCount}</strong> 个）</div>
                    <div class="text-xs mt-1 text-blue-500">GitHub API 限制最多显示100个结果，请使用更具体的关键词</div>
                `;
            } else {
                statsElement.textContent = `共找到 ${totalCount} 个结果`;
            }
            
            const fileList = DOMManager.elements.fileList;
            if (fileList) {
                fileList.appendChild(statsElement);
            }
            
            // 如果结果很多，显示提示
            if (totalCount > 100) {
                ToastManager.show(`找到 ${totalCount} 个结果，显示前100个`);
            }
        }
    },

    // 更新面包屑导航
    updateBreadcrumb(parts) {
        const breadcrumbContainer = DOMManager.elements.currentPath?.querySelector('.breadcrumb');
        if (!breadcrumbContainer) return;
        breadcrumbContainer.innerHTML = '';
        
        const rootItem = document.createElement('div');
        rootItem.className = 'breadcrumb-item';
        rootItem.innerHTML = '<i class="fab fa-github mr-1"></i><span>我的仓库</span>';
        rootItem.onclick = () => this.loadRepositories();
        breadcrumbContainer.appendChild(rootItem);
            
        if (parts.length === 0) return;
        
        if (parts[0].startsWith('搜索结果:')) {
            this.addBreadcrumbSeparator(breadcrumbContainer);
            
            const searchItem = document.createElement('div');
            searchItem.className = 'breadcrumb-item';
            searchItem.textContent = parts[0].replace('搜索结果: "', '').replace('"', '');
            searchItem.onclick = () => {
                const query = parts[0].match(/"([^"]+)"/)[1];
                this.loadSearchResults(query);
            };
            breadcrumbContainer.appendChild(searchItem);
            return;
        }
        
        this.addBreadcrumbSeparator(breadcrumbContainer);
        
        const repoItem = document.createElement('div');
        const repoName = parts[0].split('/').pop();
        repoItem.textContent = repoName;
        repoItem.onclick = () => this.loadRepositoryContents(parts[0]);
        breadcrumbContainer.appendChild(repoItem);
        
        for (let i = 1; i < parts.length; i++) {
            this.addBreadcrumbSeparator(breadcrumbContainer);
            
            const pathItem = document.createElement('div');
            pathItem.className = 'breadcrumb-item';
            pathItem.textContent = parts[i];
            
            const currentPath = parts.slice(1, i + 1).join('/');
            pathItem.onclick = () => {
                this.loadRepositoryContents(parts[0], currentPath);
            };
            
            breadcrumbContainer.appendChild(pathItem);
        }
    },
    
    // 添加面包屑分隔符
    addBreadcrumbSeparator(container) {
        const separator = document.createElement('div');
        separator.className = 'breadcrumb-separator';
        separator.innerHTML = '<i class="fas fa-chevron-right"></i>';
        container.appendChild(separator);
    },
    
    // 更新静态网站按钮状态
    updateStaticSiteButton(contents, path) {
        const hasWebContent = contents.some(file => 
            file.type === 'file' && 
            (file.name.toLowerCase() === 'index.html' || 
             file.name.toLowerCase() === 'index.md')
        );
        
        const isRoot = path === '';
        
        if (hasWebContent && isRoot) {
            DOMManager.show(DOMManager.elements.staticSiteBtn);
        } else {
            DOMManager.hide(DOMManager.elements.staticSiteBtn);
        }
    },

    // 返回上一级 - 修复版本
    goBack() {
        const currentState = history.state;
        
        // 如果有历史状态，使用浏览器后退
        if (history.length > 1) {
            history.back();
            return;
        }
        
        // 备用逻辑：基于当前状态判断
        if (StateManager.currentRepo && StateManager.currentPath && StateManager.currentSearchQuery) {
            // 搜索结果仓库的子目录 -> 返回仓库根目录（使用缓存）
            this.loadRepositoryContents(StateManager.currentRepo, '', true);
        } else if (StateManager.currentRepo && StateManager.currentSearchQuery) {
            // 搜索结果仓库的根目录 -> 返回搜索结果（使用缓存）
            this.loadSearchResults(StateManager.currentSearchQuery, 1, true);
        } else if (StateManager.currentRepo) {
            // 普通仓库 -> 返回仓库列表（使用缓存）
            this.loadRepositories(true);
        } else if (StateManager.currentSearchQuery) {
            // 搜索结果列表 -> 返回仓库列表（使用缓存）
            this.loadRepositories(true);
        } else {
            // 默认返回仓库列表（使用缓存）
            this.loadRepositories(true);
        }
    }
};


// ==================== 编辑器管理模块 ====================
const EditorManager = {
    // 初始化编辑器（保持不变）
    async init() {
        if (StateManager.monacoInitialized) return Promise.resolve();
        if (StateManager.monacoLoadPromise) return StateManager.monacoLoadPromise;
        
        StateManager.monacoLoadAttempted = true;
        
        StateManager.monacoLoadPromise = new Promise((resolve, reject) => {
            if (window.monaco && window.monaco.editor) {
                StateManager.monacoInitialized = true;
                return resolve();
            }
            
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/monaco-editor@0.47.0/min/vs/loader.min.js';
            script.crossOrigin = "anonymous";
            script.onload = () => {
                window.require.config({
                    paths: { 
                        'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.47.0/min/vs'
                    },
                    'vs/nls': {
                        availableLanguages: { '*': 'zh-cn' }
                    }
                });
                
                window.require(['vs/editor/editor.main'], () => {
                    try {
                        const editorOptions = {
                            value: '',
                            language: 'text',
                            theme: 'vs',
                            automaticLayout: true,
                            fontSize: 14,
                            minimap: { enabled: true },
                            scrollBeyondLastLine: false,
                            wordWrap: 'on',
                            wrappingIndent: 'indent'
                        };

                        if (window.innerWidth <= 768) {
                            editorOptions.minimap = { enabled: false };
                            editorOptions.fontSize = 10;
                            editorOptions.lineHeight = 16;
                        }

                        StateManager.editor = monaco.editor.create(document.getElementById('editor'), editorOptions);
                        StateManager.monacoInitialized = true;
                        
                        StateManager.editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
                            this.saveFileChanges();
                        });

                        if (window.innerWidth <= 768) {
                            window.addEventListener('resize', this.handleMobileKeyboard);
                        }
                        
                        resolve();
                    } catch (createError) {
                        console.error('创建Monaco编辑器实例失败:', createError);
                        this.createFallbackEditor();
                        resolve();
                    }
                });
                
                window.require.onError = (err) => {
                    console.error('加载Monaco编辑器失败:', err);
                    this.createFallbackEditor();
                    resolve();
                };
            };
            
            script.onerror = (err) => {
                console.error('加载Monaco脚本失败:', err);
                this.createFallbackEditor();
                resolve();
            };
            
            document.head.appendChild(script);
        });
        
        return StateManager.monacoLoadPromise;
    },

    // 创建备用编辑器
    createFallbackEditor() {
        const editorContainer = document.getElementById('editor');
        if (editorContainer) {
            editorContainer.innerHTML = `
                <textarea id="fallback-editor" style="width:100%;height:100%;font-family:monospace;padding:10px;border:none;outline:none;resize:none;"></textarea>
            `;
        }
        console.log('创建了备用编辑器');
    },

    // 在编辑器中打开文件 - 修复显示问题
    async openFileInEditor(fileInfo) {
        if (fileInfo.size > 1024 * 1024) {
            ToastManager.show('文件过大，请在浏览器中查看');
            return;
        }
        
        const fileExt = fileInfo.name.split('.').pop().toLowerCase();
        if (!Config.textFileExtensions.includes(fileExt)) {
            ToastManager.show('不支持编辑此文件类型');
            return;
        }
        
        try {
            ToastManager.show('正在加载文件内容...');
            
            // 创建新的编辑文件对象
            StateManager.currentEditingFile = {
                ...fileInfo,
                path: StateManager.currentPath ? `${StateManager.currentPath}/${fileInfo.name}` : fileInfo.name
            };
            
            // 获取文件内容和SHA
            const fileContent = await this.getFileContentForEditor(StateManager.currentEditingFile.path);
            
            StateManager.currentEditingFile.sha = fileContent.sha;
            StateManager.currentEditingFile.content = fileContent.content;
            
            // 初始化编辑器并设置内容
            await this.init();
            this.setEditorContent(fileContent.content, fileExt);
            
            ToastManager.show('文件加载完成');
            
        } catch (error) {
            console.error('打开编辑器失败:', error);
            ToastManager.show('加载文件失败: ' + error.message);
            StateManager.currentEditingFile = null;
        }
    },

    // 获取文件内容用于编辑器
    async getFileContentForEditor(filePath) {
        try {
            console.log('获取文件内容:', filePath);
            
            const response = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
                {
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                }
            );
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || '获取文件内容失败');
            }
            
            const data = await response.json();
            console.log('获取到文件数据:', data);
            
            // 使用改进的Base64解码方法
            let decodedContent;
            try {
                decodedContent = this.decodeBase64ContentSafe(data.content);
            } catch (decodeError) {
                console.error('Base64解码失败:', decodeError);
                // 尝试备用解码方法
                decodedContent = this.fallbackDecodeBase64(data.content);
            }
            
            return {
                content: decodedContent,
                sha: data.sha
            };
        } catch (error) {
            console.error('获取文件内容错误:', error);
            throw error;
        }
    },

    // 安全的Base64解码方法
    decodeBase64ContentSafe(base64) {
        try {
            // 方法1: 使用标准的atob
            const binaryString = atob(base64);
            
            // 方法2: 处理UTF-8字符
            try {
                // 使用TextDecoder处理UTF-8
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                // 如果UTF-8解码失败，尝试escape/unescape方法
                try {
                    return decodeURIComponent(escape(binaryString));
                } catch (e2) {
                    // 最后返回原始二进制字符串
                    console.warn('使用原始二进制字符串作为内容');
                    return binaryString;
                }
            }
        } catch (error) {
            console.error('Base64解码错误:', error);
            throw new Error('文件内容解码失败');
        }
    },

    // 备用Base64解码方法
    fallbackDecodeBase64(base64) {
        try {
            // 直接使用atob
            return atob(base64);
        } catch (e) {
            // 如果所有方法都失败，返回空字符串
            console.error('所有Base64解码方法都失败');
            return '';
        }
    },

    // 设置编辑器内容 - 修复显示问题
    setEditorContent(content, fileExt) {
        console.log('设置编辑器内容，文件类型:', fileExt);
        
        // 首先确保编辑器容器可见
        this.showEditorContainer();
        
        // 设置内容到编辑器
        if (StateManager.editor && StateManager.editor.setValue) {
            console.log('使用Monaco编辑器设置内容');
            StateManager.editor.setValue(content || '');
            
            const language = Config.languageMapping[fileExt] || 'text';
            console.log('设置编辑器语言:', language);
            monaco.editor.setModelLanguage(StateManager.editor.getModel(), language);
            
            // 强制重新布局
            setTimeout(() => {
                if (StateManager.editor && StateManager.editor.layout) {
                    StateManager.editor.layout();
                }
            }, 100);
            
        } else if (document.getElementById('fallback-editor')) {
            console.log('使用备用编辑器设置内容');
            document.getElementById('fallback-editor').value = content || '';
        } else {
            console.error('没有找到可用的编辑器');
            this.createFallbackEditor();
            if (document.getElementById('fallback-editor')) {
                document.getElementById('fallback-editor').value = content || '';
            }
        }
        
        // 更新文件信息显示
        this.updateFileInfoDisplay(fileExt);
        
        // 聚焦编辑器
        this.focusEditor();
    },

    // 显示编辑器容器
    showEditorContainer() {
        const editorContainer = DOMManager.elements.editorContainer;
        if (!editorContainer) {
            console.error('编辑器容器元素未找到');
            return;
        }
        
        console.log('显示编辑器容器');
        
        // 使用DOMManager的方法显示容器
        DOMManager.show(editorContainer);
        
        // 确保容器有正确的样式
        editorContainer.style.display = 'flex';
        editorContainer.style.flexDirection = 'column';
        editorContainer.style.position = 'fixed';
        editorContainer.style.top = '0';
        editorContainer.style.left = '0';
        editorContainer.style.right = '0';
        editorContainer.style.bottom = '0';
        editorContainer.style.zIndex = '1000';
        editorContainer.style.background = 'white';
        
        // 隐藏主界面内容
        const mainScreen = DOMManager.elements.mainScreen;
        if (mainScreen) {
            mainScreen.style.display = 'none';
        }
        
        // 添加ESC键关闭支持
        this.bindEscapeKey();
    },

    // 更新文件信息显示
    updateFileInfoDisplay(fileExt) {
        const { editorFilename, editorFileSize, editorLanguage } = DOMManager.elements;
        
        if (editorFilename && StateManager.currentEditingFile) {
            editorFilename.textContent = StateManager.currentEditingFile.name;
        }
        
        if (editorFileSize && StateManager.currentEditingFile) {
            editorFileSize.textContent = FileManager.formatFileSize(StateManager.currentEditingFile.size);
        }
        
        if (editorLanguage) {
            editorLanguage.textContent = (Config.languageMapping[fileExt] || 'text').toUpperCase();
        }
    },

    // 聚焦编辑器
    focusEditor() {
        setTimeout(() => {
            if (StateManager.editor && StateManager.editor.focus) {
                StateManager.editor.focus();
                console.log('Monaco编辑器已聚焦');
            } else if (document.getElementById('fallback-editor')) {
                document.getElementById('fallback-editor').focus();
                console.log('备用编辑器已聚焦');
            }
        }, 200);
    },

    // 绑定ESC键关闭
    bindEscapeKey() {
        const escapeHandler = (e) => {
            if (e.key === 'Escape' && StateManager.currentEditingFile) {
                e.preventDefault();
                e.stopPropagation();
                this.closeEditor();
                document.removeEventListener('keydown', escapeHandler);
            }
        };
        
        document.addEventListener('keydown', escapeHandler);
        
        // 保存引用以便清理
        StateManager.editorEscapeHandler = escapeHandler;
    },

    // 保存文件更改
    async saveFileChanges() {
        if (!StateManager.currentEditingFile) {
            ToastManager.show('没有可保存的文件');
            return;
        }
        
        try {
            let newContent;
            if (StateManager.editor && StateManager.editor.getValue) {
                newContent = StateManager.editor.getValue();
            } else if (document.getElementById('fallback-editor')) {
                newContent = document.getElementById('fallback-editor').value;
            } else {
                throw new Error('编辑器未初始化');
            }
            
            ToastManager.show('正在保存文件...');
            
            // 获取文件当前SHA
            const fileInfo = await this.getFileInfoForSave(StateManager.currentEditingFile.path);
            
            if (!fileInfo.sha) {
                throw new Error('无法获取文件SHA，保存失败');
            }
            
            // 执行保存
            await this.saveFileContent(
                StateManager.currentEditingFile.path,
                newContent,
                fileInfo.sha,
                `更新 ${StateManager.currentEditingFile.name}`
            );
            
            ToastManager.show('文件保存成功');
this.closeEditor();
// 保存文件后刷新当前目录
AutoRefreshManager.refreshAfterFileOperation(); 
            
        } catch (error) {
            console.error('保存文件失败:', error);
            ToastManager.show('保存失败: ' + error.message);
        }
    },

    // 获取文件信息用于保存
    async getFileInfoForSave(filePath) {
        try {
            const response = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
                {
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                }
            );
            
            if (response.ok) {
                const data = await response.json();
                return { sha: data.sha, exists: true };
            } else {
                const errorData = await response.json();
                throw new Error(errorData.message || '获取文件信息失败');
            }
        } catch (error) {
            console.error('获取文件信息错误:', error);
            throw error;
        }
    },

    // 保存文件内容
    async saveFileContent(filePath, content, sha, message) {
        try {
            // 将内容编码为Base64 - 使用更安全的方法
            const base64Content = this.encodeToBase64Safe(content);
            
            const response = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: message,
                        content: base64Content,
                        sha: sha
                    })
                }
            );

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `保存失败: ${response.status}`);
            }

            return response.json();
        } catch (error) {
            console.error('保存文件内容错误:', error);
            throw error;
        }
    },

    // 安全的Base64编码方法
    encodeToBase64Safe(content) {
        try {
            // 方法1: 使用标准的btoa和escape/unescape处理中文
            return btoa(unescape(encodeURIComponent(content)));
        } catch (e) {
            // 方法2: 使用TextEncoder
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(content);
                let binary = '';
                for (let i = 0; i < data.length; i++) {
                    binary += String.fromCharCode(data[i]);
                }
                return btoa(binary);
            } catch (e2) {
                // 方法3: 直接使用btoa（可能对中文不友好）
                console.warn('使用直接btoa编码，可能丢失中文');
                return btoa(content);
            }
        }
    },

    // 关闭编辑器 - 修复版本
    closeEditor() {
        console.log('关闭编辑器');
        
        const editorContainer = DOMManager.elements.editorContainer;
        if (editorContainer) {
            // 隐藏编辑器容器
            DOMManager.hide(editorContainer);
            editorContainer.style.display = 'none';
        }
        
        // 显示主界面
        const mainScreen = DOMManager.elements.mainScreen;
        if (mainScreen) {
            mainScreen.style.display = 'block';
        }
        
        // 清理ESC键事件监听器
        if (StateManager.editorEscapeHandler) {
            document.removeEventListener('keydown', StateManager.editorEscapeHandler);
            StateManager.editorEscapeHandler = null;
        }
        
        StateManager.currentEditingFile = null;
        
        console.log('编辑器已关闭');
    },

    // 移动端键盘处理
    handleMobileKeyboard() {
        if (!StateManager.editor) return;
        
        const editorContainer = DOMManager.elements.editorContainer;
        const editorElement = document.getElementById('editor');
        
        if (window.innerHeight < window.outerHeight * 0.9) {
            editorContainer.style.position = 'absolute';
            editorContainer.style.top = '0';
            editorContainer.style.height = (window.innerHeight - 100) + 'px';
            editorElement.style.height = (window.innerHeight - 150) + 'px';
        } else {
            editorContainer.style.position = 'fixed';
            editorContainer.style.height = '100%';
            editorElement.style.height = '';
        }
        
        if (StateManager.editor.layout) {
            StateManager.editor.layout();
        }
    }
};

// ==================== 选择管理模块 ====================
const SelectionManager = {
    // 进入选择模式
    enterSelectMode() {
        const selectBtn = DOMManager.elements.selectBtn;
        if (selectBtn) {
            selectBtn.innerHTML = '<i class="fas fa-times text-red-500"></i>';
            selectBtn.title = '取消选择';
        }
        
        // 添加选择模式样式提示
        document.querySelectorAll('.file-item').forEach(item => {
            item.style.cursor = 'pointer';
        });
        
        DOMManager.showBatchToolbar();
        StateManager.clearSelectedFiles();
    },

    // 退出选择模式
    exitSelectMode() {
        StateManager.clearSelectedFiles();
        DOMManager.hideBatchToolbar();
        
        // 移除所有选中状态
        document.querySelectorAll('.file-item.selected').forEach(item => {
            item.classList.remove('selected');
        });
        
        const selectBtn = DOMManager.elements.selectBtn;
        if (selectBtn) {
            selectBtn.innerHTML = '<i class="fas fa-check-square text-blue-500"></i>';
            selectBtn.title = '选择文件';
        }
        
        // 恢复默认样式
        document.querySelectorAll('.file-item').forEach(item => {
            item.style.cursor = '';
        });
    },

    // 切换选择模式
    toggleSelectMode() {
        if (StateManager.selectedFiles.size > 0 || this.isInSelectMode()) {
            this.exitSelectMode();
        } else {
            this.enterSelectMode();
        }
    },

    // 检查是否在选择模式
    isInSelectMode() {
        const selectBtn = DOMManager.elements.selectBtn;
        return selectBtn && selectBtn.innerHTML.includes('fa-times');
    },

    // 处理文件选择
    handleFileSelection(fileItem, fileInfo) {
        if (!this.isInSelectMode()) {
            return false; // 不在选择模式，不处理选择
        }

        if (fileItem.classList.contains('selected')) {
            fileItem.classList.remove('selected');
            StateManager.removeSelectedFile(fileInfo);
        } else {
            fileItem.classList.add('selected');
            StateManager.addSelectedFile(fileInfo);
        }

        // 更新选中数量显示
        this.updateSelectionCount();

        // 如果没有选中文件，退出选择模式
        if (StateManager.selectedFiles.size === 0) {
            this.exitSelectMode();
        }

        return true; // 已处理选择
    },

    // 更新选中数量显示
    updateSelectionCount() {
        const selectedCount = document.getElementById('selected-count');
        if (selectedCount) {
            selectedCount.textContent = StateManager.selectedFiles.size;
        }
    },

    // 下载选中的文件 - 修复版本
async downloadSelectedFiles() {
    if (StateManager.selectedFiles.size === 0) {
        ToastManager.show('请先选择文件');
        return;
    }

    // 单个文件直接下载
    if (StateManager.selectedFiles.size === 1) {
        const file = Array.from(StateManager.selectedFiles)[0];
        await FileManager.downloadFile(file);
        this.exitSelectMode();
        return;
    }

    // 多个文件打包下载
    try {
        const files = Array.from(StateManager.selectedFiles);
        ToastManager.show(`开始打包 ${files.length} 个文件...`);
        
        // 检查是否支持JSZip
        if (typeof JSZip === 'undefined') {
            throw new Error('打包功能需要JSZip库支持');
        }
        
        const zip = new JSZip();
        let successCount = 0;
        let errorCount = 0;

        // 创建进度提示
        const progressToast = ToastManager.createProgressToast(`准备打包 ${files.length} 个文件...`);

        // 分批下载避免内存溢出
        const BATCH_SIZE = 5;
        
        for (let i = 0; i < files.length; i += BATCH_SIZE) {
            const batch = files.slice(i, i + BATCH_SIZE);
            const batchPromises = batch.map(async (file, index) => {
                if (file.type !== 'file' || !file.download_url) {
                    errorCount++;
                    return null;
                }
                
                try {
                    progressToast.textContent = `下载中: ${i + index + 1}/${files.length} - ${file.name}`;
                    
                    const response = await fetch(file.download_url, {
                        headers: {
                            'Accept': '*/*',
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const blob = await response.blob();
                    
                    if (!blob || blob.size === 0) {
                        throw new Error('文件内容为空');
                    }
                    
                    // 构建文件路径，保持目录结构
                    let filePath = file.name;
                    if (file.path && file.path.includes('/')) {
                        const pathParts = file.path.split('/');
                        pathParts.pop(); // 移除文件名
                        if (pathParts.length > 0) {
                            filePath = pathParts.join('/') + '/' + file.name;
                        }
                    }
                    
                    zip.file(filePath, blob);
                    successCount++;
                    
                    return file.name;
                    
                } catch (error) {
                    console.error(`下载 ${file.name} 失败:`, error);
                    errorCount++;
                    progressToast.textContent = `下载中: ${i + index + 1}/${files.length} (${errorCount} 失败)`;
                    return null;
                }
            });

            // 等待当前批次完成
            await Promise.all(batchPromises);
            
            // 小延迟避免速率限制
            if (i + BATCH_SIZE < files.length) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        if (successCount === 0) {
            ToastManager.show('没有文件成功下载');
            ToastManager.removeProgressToast();
            return;
        }
        
        // 生成ZIP文件
        progressToast.textContent = '正在生成压缩文件...';
        
        const content = await zip.generateAsync({
            type: 'blob',
            compression: 'DEFLATE',
            compressionOptions: { level: 6 }
        });
        
        // 触发下载
        const repoName = StateManager.currentRepo.split('/')[1] || 'download';
        const dateString = new Date().toISOString().slice(0, 10);
        const zipFilename = `${repoName}-files-${dateString}.zip`;
        
        const url = URL.createObjectURL(content);
        const link = document.createElement('a');
        link.href = url;
        link.download = zipFilename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        
        // 清理
        setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }, 100);
        
        ToastManager.removeProgressToast();
        
        if (errorCount === 0) {
            ToastManager.show(`成功打包下载 ${successCount} 个文件`);
        } else {
            ToastManager.show(`打包完成: ${successCount} 成功, ${errorCount} 失败`);
        }
        
    } catch (error) {
        console.error('打包下载失败:', error);
        ToastManager.removeProgressToast();
        ToastManager.show('打包下载失败: ' + error.message);
    } finally {
        this.exitSelectMode();
    }
},

    // 删除选中的文件
    async deleteSelectedFiles() {
        if (StateManager.selectedFiles.size === 0) {
            ToastManager.show('请先选择文件');
            return;
        }

        const files = Array.from(StateManager.selectedFiles);
        DialogManager.showConfirmDialog(
            '确认删除',
            `您确定要删除选中的 ${files.length} 个文件吗？此操作不可撤销。`,
            files
        );
    }
};

// ==================== 对话框管理模块 ====================
const DialogManager = {
    // 显示确认对话框
    showConfirmDialog(title, message, fileInfo) {
        const { confirmDialog, confirmTitle, confirmMessage } = DOMManager.elements;
        
        confirmTitle.textContent = title;
        confirmMessage.textContent = message;
        StateManager.fileToDelete = fileInfo;
        
        confirmDialog.classList.add('opacity-100', 'pointer-events-auto');
        confirmDialog.querySelector('.dialog-content').classList.add('scale-100');
        confirmDialog.querySelector('.dialog-content').classList.remove('scale-90');
    },

    // 隐藏确认对话框
    hideConfirmDialog() {
        const { confirmDialog } = DOMManager.elements;
        
        confirmDialog.classList.remove('opacity-100', 'pointer-events-auto');
        confirmDialog.querySelector('.dialog-content').classList.add('scale-90');
        confirmDialog.querySelector('.dialog-content').classList.remove('scale-100');
        StateManager.fileToDelete = null;
    },

    // 显示新建文件夹对话框
    showNewFolderDialog() {
        const { newFolderDialog, newFolderName } = DOMManager.elements;
        
        newFolderName.value = '';
        newFolderDialog.classList.add('opacity-100', 'pointer-events-auto');
        newFolderDialog.querySelector('.dialog-content').classList.add('scale-100');
        newFolderDialog.querySelector('.dialog-content').classList.remove('scale-90');
        newFolderName.focus();
    },

    // 隐藏新建文件夹对话框
    hideNewFolderDialog() {
        const { newFolderDialog } = DOMManager.elements;
        
        newFolderDialog.classList.remove('opacity-100', 'pointer-events-auto');
        newFolderDialog.querySelector('.dialog-content').classList.add('scale-90');
        newFolderDialog.querySelector('.dialog-content').classList.remove('scale-100');
    },

    // 显示新建仓库对话框
    showNewRepoDialog() {
        const { newRepoDialog, newRepoName, newRepoDesc, newRepoPrivate } = DOMManager.elements;
        
        newRepoName.value = '';
        newRepoDesc.value = '';
        newRepoPrivate.checked = false;
        newRepoDialog.classList.add('opacity-100', 'pointer-events-auto');
        newRepoDialog.querySelector('.dialog-content').classList.add('scale-100');
        newRepoDialog.querySelector('.dialog-content').classList.remove('scale-90');
        newRepoName.focus();
    },

    // 隐藏新建仓库对话框
    hideNewRepoDialog() {
        const { newRepoDialog } = DOMManager.elements;
        
        newRepoDialog.classList.remove('opacity-100', 'pointer-events-auto');
        newRepoDialog.querySelector('.dialog-content').classList.add('scale-90');
        newRepoDialog.querySelector('.dialog-content').classList.remove('scale-100');
    },

    // 显示上传文件对话框
    showUploadDialog() {
        const { uploadDialog, fileInput } = DOMManager.elements;
        
        fileInput.value = '';
        uploadDialog.classList.add('opacity-100', 'pointer-events-auto');
        uploadDialog.querySelector('.dialog-content').classList.add('scale-100');
        uploadDialog.querySelector('.dialog-content').classList.remove('scale-90');
    },

    // 隐藏上传文件对话框
    hideUploadDialog() {
        const { uploadDialog } = DOMManager.elements;
        
        uploadDialog.classList.remove('opacity-100', 'pointer-events-auto');
        uploadDialog.querySelector('.dialog-content').classList.add('scale-90');
        uploadDialog.querySelector('.dialog-content').classList.remove('scale-100');
    },

    // 显示复刻仓库对话框
    showForkRepoDialog() {
        const { forkRepoDialog, forkRepoUrl } = DOMManager.elements;
        
        forkRepoUrl.value = '';
        forkRepoDialog.classList.add('opacity-100', 'pointer-events-auto');
        forkRepoDialog.querySelector('.dialog-content').classList.add('scale-100');
        forkRepoDialog.querySelector('.dialog-content').classList.remove('scale-90');
    },

    // 隐藏复刻仓库对话框
    hideForkRepoDialog() {
        const { forkRepoDialog } = DOMManager.elements;
        
        forkRepoDialog.classList.remove('opacity-100', 'pointer-events-auto');
        forkRepoDialog.querySelector('.dialog-content').classList.add('scale-90');
        forkRepoDialog.querySelector('.dialog-content').classList.remove('scale-100');
    },

    // 显示部署网站对话框
    showStaticSiteDialog() {
        const { staticSiteDialog, pagesBranch, pagesFolder, pagesStatus, staticSiteEnable } = DOMManager.elements;
        
        // 智能预填充设置
        pagesBranch.value = 'main';
        pagesFolder.value = '/';
        
        // 检查是否存在docs目录，如果存在则优先推荐
        const hasDocs = StateManager.currentFiles.some(file => 
            file.type === 'dir' && file.name.toLowerCase() === 'docs'
        );
        
        if (hasDocs) {
            pagesFolder.value = '/docs';
        }
        
        // 更新状态显示
        this.updatePagesStatusDisplay();
        
        staticSiteDialog.classList.add('opacity-100', 'pointer-events-auto');
        staticSiteDialog.querySelector('.dialog-content').classList.add('scale-100');
        staticSiteDialog.querySelector('.dialog-content').classList.remove('scale-90');
    },

    // 隐藏部署网站对话框
    hideStaticSiteDialog() {
        const { staticSiteDialog } = DOMManager.elements;
        
        staticSiteDialog.classList.remove('opacity-100', 'pointer-events-auto');
        staticSiteDialog.querySelector('.dialog-content').classList.add('scale-90');
        staticSiteDialog.querySelector('.dialog-content').classList.remove('scale-100');
    },

    // 更新Pages状态显示 
async updatePagesStatusDisplay() {
    const { pagesStatus, staticSiteEnable, pagesUrl, pagesBranch, pagesFolder } = DOMManager.elements;
    
    // 获取目标仓库
    const targetRepo = StateManager.contextMenuTarget ? 
        ContextMenuManager.getTargetRepo(StateManager.contextMenuTarget) : 
        StateManager.currentRepo;
        
    const isEnabled = StateManager.pagesEnabledMap.get(targetRepo) || false;
    
    if (isEnabled) {
        pagesStatus.classList.remove('hidden');
        staticSiteEnable.classList.add('hidden');
        
        try {
            const [owner, repoName] = targetRepo.split('/');
            const data = await APIService.getPagesStatus(owner, repoName);
            pagesUrl.href = data.html_url;
            pagesUrl.textContent = data.html_url;
            
            // 更新分支和目录显示
            pagesBranch.value = data.source.branch;
            pagesFolder.value = data.source.path === '/docs' ? '/docs' : '/';
        } catch (error) {
            console.error('获取Pages详情失败:', error);
        }
    } else {
        pagesStatus.classList.add('hidden');
        staticSiteEnable.classList.remove('hidden');
    }
},

    // 通用对话框隐藏函数
    hideDialog(dialogElement) {
        dialogElement.classList.remove('opacity-100', 'pointer-events-auto');
        dialogElement.querySelector('.dialog-content').classList.add('scale-90');
        dialogElement.querySelector('.dialog-content').classList.remove('scale-100');
    }
};

// ==================== 上下文菜单管理模块（最终修复版） ====================
const ContextMenuManager = {
    isSearchResultPage: false,
    // 显示上下文菜单（主入口）
    show(e, fileInfo, isSearchResultRepo = false) {
        e.preventDefault();
        e.stopPropagation();
        const oldMask = document.getElementById('context-menu-mask');
        if (oldMask) oldMask.remove();
        const mask = document.createElement('div');
        mask.id = 'context-menu-mask';
        mask.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            z-index: 999;
        `;
        document.body.appendChild(mask);
        const targetIsSearchRepo = isSearchResultRepo || (this.isSearchResultPage && fileInfo.type === 'repo');
        StateManager.contextMenuTarget = fileInfo;
        // 关键：直接根据fileInfo的pagesEnabled属性判断（仓库列表已显示标签则该属性为true）
        const isPagesEnabled = fileInfo.type === 'repo' && fileInfo.pagesEnabled === true;
        this.renderTargetMenu(fileInfo, targetIsSearchRepo, isPagesEnabled);
        this.positionMenu(e);
        mask.style.display = 'block';
        mask.addEventListener('click', () => this.hide());
        const { contextMenu } = DOMManager.elements;
        contextMenu.classList.add('visible');
    },
    // 渲染目标菜单（直接接收pagesEnabled状态）
    renderTargetMenu(fileInfo, targetIsSearchRepo, isPagesEnabled) {
        if (fileInfo.type === 'repo') {
            targetIsSearchRepo ? this.renderSearchResultRepoMenu(isPagesEnabled) : this.renderLocalRepoMenu(isPagesEnabled);
        } else {
            this.renderFileFolderMenu(fileInfo);
        }
    },
    // 渲染本地仓库菜单（方法a）
    renderLocalRepoMenu(isPagesEnabled) {
        const {
            contextOpen, contextDownloadSource, contextEnablePages,
            contextBuildApp, contextCopyRepoLink, contextCopySiteLink,
            contextRenameRepo, contextDelete
        } = DOMManager.elements;
        this.resetAllMenuVisibility();
        contextOpen.style.display = 'flex';
        contextCopyRepoLink.style.display = 'flex';
        contextDownloadSource.style.display = 'flex';
        contextDelete.style.display = 'flex';
        contextRenameRepo.style.display = 'flex';
        contextEnablePages.style.display = 'flex';
        contextBuildApp.style.display = 'flex';
        // 核心修复：移除hidden类并根据状态控制显示
        contextCopySiteLink.classList.remove('hidden');
        contextCopySiteLink.style.display = isPagesEnabled ? 'flex' : 'none';
        this.updatePagesMenuButton(StateManager.contextMenuTarget, isPagesEnabled);
    },
    // 渲染搜索结果仓库菜单（方法b）
    renderSearchResultRepoMenu(isPagesEnabled) {
        const {
            contextOpen, contextDownloadSource, contextCopyRepoLink,
            contextCopySiteLink
        } = DOMManager.elements;
        this.resetAllMenuVisibility();
        contextOpen.style.display = 'flex';
        contextCopyRepoLink.style.display = 'flex';
        contextDownloadSource.style.display = 'flex';
        // 核心修复：添加复制网站链接按钮并控制显示
        contextCopySiteLink.classList.remove('hidden');
        contextCopySiteLink.style.display = isPagesEnabled ? 'flex' : 'none';
        this.addForkButtonForSearchRepo(StateManager.contextMenuTarget);
        this.addVisitRepoButtonForSearchRepo(StateManager.contextMenuTarget);
    },
    // 渲染文件/文件夹通用菜单
    renderFileFolderMenu(fileInfo) {
        const {
            contextOpen, contextDownload, contextRename,
            contextCopyLink, contextCopyProxyLink, contextDelete
        } = DOMManager.elements;
        this.resetAllMenuVisibility();
        if (fileInfo.type === 'dir') contextOpen.style.display = 'flex';
        if (fileInfo.type === 'file') {
            contextDownload.style.display = 'flex';
            contextRename.style.display = 'flex';
            contextCopyLink.style.display = 'flex';
            contextCopyProxyLink.style.display = 'flex';
        }
        contextDelete.style.display = 'flex';
        this.removeForkButtonForSearchRepo();
    },
    // 重置所有菜单为隐藏状态
    resetAllMenuVisibility() {
        const menuItems = [
            DOMManager.elements.contextOpen,
            DOMManager.elements.contextDownload,
            DOMManager.elements.contextRename,
            DOMManager.elements.contextCopyLink,
            DOMManager.elements.contextCopyProxyLink,
            DOMManager.elements.contextDelete,
            DOMManager.elements.contextDownloadSource,
            DOMManager.elements.contextEnablePages,
            DOMManager.elements.contextBuildApp,
            DOMManager.elements.contextCopyRepoLink,
            DOMManager.elements.contextCopySiteLink,
            DOMManager.elements.contextRenameRepo
        ];
        menuItems.forEach(item => item && (item.style.display = 'none'));
        this.removeForkButtonForSearchRepo();
    },
    // 设置是否为搜索结果页面
    setIsSearchResultPage(status) {
        this.isSearchResultPage = status;
    },
    // 绑定搜索上下文菜单事件
    bindSearchContextMenuEvents() {
        const { searchContextFork, searchContextCopyLink, searchContextVisit } = DOMManager.elements;
        searchContextFork?.addEventListener('click', () => this.handleSearchMenuItemClick('fork'));
        searchContextCopyLink?.addEventListener('click', () => this.handleSearchMenuItemClick('copy-link'));
        searchContextVisit?.addEventListener('click', () => this.handleSearchMenuItemClick('visit'));
    },
    // 添加搜索结果仓库「访问仓库」按钮
    addVisitRepoButtonForSearchRepo(fileInfo) {
        const visitBtn = document.getElementById('context-visit-repo');
        if (visitBtn && visitBtn.parentNode) visitBtn.parentNode.removeChild(visitBtn);
        const contextMenu = DOMManager.elements.contextMenu;
        const newVisitBtn = document.createElement('div');
        newVisitBtn.id = 'context-visit-repo';
        newVisitBtn.className = 'context-menu-item';
        newVisitBtn.innerHTML = '<i class="fas fa-external-link-alt text-blue-500"></i><span class="text-blue-500">访问仓库</span>';
        newVisitBtn.addEventListener('click', () => {
            window.open(`https://github.com/${fileInfo.path}`, '_blank');
            this.hide();
        });
        const copyRepoLink = DOMManager.elements.contextCopyRepoLink;
        copyRepoLink ? copyRepoLink.after(newVisitBtn) : contextMenu && contextMenu.appendChild(newVisitBtn);
    },
    // 添加搜索结果仓库「复刻仓库」按钮
    addForkButtonForSearchRepo(fileInfo) {
        this.removeForkButtonForSearchRepo();
        const contextMenu = DOMManager.elements.contextMenu;
        const forkBtn = document.createElement('div');
        forkBtn.id = 'context-fork-repo';
        forkBtn.className = 'context-menu-item';
        forkBtn.innerHTML = '<i class="fas fa-code-branch text-blue-500"></i><span class="text-blue-500">复刻仓库</span>';
        forkBtn.addEventListener('click', () => {
            this.forkRepository(fileInfo);
            this.hide();
        });
        const visitBtn = document.getElementById('context-visit-repo');
        visitBtn ? visitBtn.after(forkBtn) : contextMenu && contextMenu.appendChild(forkBtn);
    },
    // 移除搜索结果仓库专属按钮
    removeForkButtonForSearchRepo() {
        const forkBtn = document.getElementById('context-fork-repo');
        if (forkBtn && forkBtn.parentNode) forkBtn.parentNode.removeChild(forkBtn);
        const visitBtn = document.getElementById('context-visit-repo');
        if (visitBtn && visitBtn.parentNode) visitBtn.parentNode.removeChild(visitBtn);
    },
    // 更新Pages菜单按钮状态
    updatePagesMenuButton(fileInfo, isEnabled) {
        const { contextEnablePages } = DOMManager.elements;
        if (!contextEnablePages) return;
        const finalIsEnabled = isEnabled !== undefined ? isEnabled : fileInfo.pagesEnabled === true;
        contextEnablePages.innerHTML = finalIsEnabled ?
            '<i class="fas fa-ban mr-2 text-red-500"></i><span class="text-red-500">禁用网站</span>' :
            '<i class="fas fa-globe mr-2 text-green-500"></i><span class="text-green-500">部署网站</span>';
    },
    // 检查仓库Pages状态（备用方法，优先使用fileInfo.pagesEnabled）
    async checkPagesStatus(repo) {
        try {
            const [owner, repoName] = repo.split('/');
            const data = await APIService.getPagesStatus(owner, repoName);
            const isEnabled = data.status === 'built' || data.status === 'building';
            StateManager.pagesEnabledMap.set(repo, isEnabled);
            return isEnabled;
        } catch (error) {
            console.error('检查Pages状态错误:', error);
            StateManager.pagesEnabledMap.set(repo, false);
            return false;
        }
    },
    // 获取目标仓库路径
    getTargetRepo(fileInfo) {
        return fileInfo.type === 'repo' ? fileInfo.path : StateManager.currentRepo;
    },
    // 定位菜单位置
    positionMenu(e) {
        const { contextMenu } = DOMManager.elements;
        const menuWidth = contextMenu.offsetWidth;
        const menuHeight = contextMenu.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const triggerX = e.clientX;
        const triggerY = e.clientY;
        const spaceBelow = viewportHeight - triggerY;
        const spaceAbove = triggerY;
        const spaceRight = viewportWidth - triggerX;
        const spaceLeft = triggerX;
        let posX = triggerX;
        let posY = triggerY + 5;
        if (spaceBelow < menuHeight && spaceAbove > menuHeight) posY = triggerY - menuHeight - 5;
        else if (spaceBelow < menuHeight) posY = viewportHeight - menuHeight - 10;
        if (spaceRight < menuWidth && spaceLeft > menuWidth) posX = triggerX - menuWidth - 5;
        else if (spaceRight < menuWidth) posX = viewportWidth - menuWidth - 10;
        posX = Math.max(10, Math.min(posX, viewportWidth - menuWidth - 10));
        posY = Math.max(10, Math.min(posY, viewportHeight - menuHeight - 10));
        contextMenu.style.left = `${posX}px`;
        contextMenu.style.top = `${posY}px`;
    },
    // 隐藏菜单
    hide() {
        const mask = document.getElementById('context-menu-mask');
        if (mask) mask.remove();
        const { contextMenu } = DOMManager.elements;
        contextMenu.classList.remove('visible');
        contextMenu.style.left = '-9999px';
        contextMenu.style.top = '-9999px';
        StateManager.contextMenuTarget = null;
        this.removeForkButtonForSearchRepo();
        document.removeEventListener('click', this.hide);
    },
    // 处理菜单项点击
    handleMenuItemClick(action) {
        if (!StateManager.contextMenuTarget) return;
        switch (action) {
            case 'open': this.openContextItem(StateManager.contextMenuTarget); break;
            case 'download': FileManager.downloadFile(StateManager.contextMenuTarget); break;
            case 'rename': this.renameFile(StateManager.contextMenuTarget); break;
            case 'copy-link': this.copyFileLink(StateManager.contextMenuTarget, 'raw'); break;
            case 'copy-proxy-link': this.copyFileLink(StateManager.contextMenuTarget, 'cdn'); break;
            case 'copy-repo-link': this.copyRepoLink(StateManager.contextMenuTarget); break;
            case 'copy-site-link': this.copySiteLink(StateManager.contextMenuTarget); break;
            case 'rename-repo': this.renameRepository(StateManager.contextMenuTarget); break;
            case 'delete': this.deleteContextItem(StateManager.contextMenuTarget); break;
            case 'download-source': this.downloadRepositorySource(StateManager.contextMenuTarget); break;
            case 'enable-pages': this.toggleGitHubPages(StateManager.contextMenuTarget); break;
            case 'build-app': this.buildApp(StateManager.contextMenuTarget); break;
        }
        this.hide();
    },
    // 复制仓库链接
    copyRepoLink(repoInfo) {
        const repoUrl = `https://github.com/${repoInfo.path}`;
        this.copyToClipboard(repoUrl, '仓库链接已复制');
    },
    // 复制网站链接
    copySiteLink(repoInfo) {
        const [owner, repoName] = repoInfo.path.split('/');
        const siteUrl = `https://${owner}.github.io/${repoName}`;
        this.copyToClipboard(siteUrl, '网站链接已复制');
    },
    // 打开菜单项目标
    openContextItem(fileInfo) {
        if (fileInfo.type === 'dir') {
            NavigationManager.loadRepositoryContents(
                StateManager.currentRepo,
                `${StateManager.currentPath ? StateManager.currentPath + '/' : ''}${fileInfo.name}`
            );
        } else if (fileInfo.type === 'repo') {
            this.setIsSearchResultPage(false);
            NavigationManager.loadRepositoryContents(fileInfo.path);
        } else if (fileInfo.type === 'file' && fileInfo.download_url) {
            window.open(fileInfo.download_url, '_blank');
        }
    },
    // 重命名文件
    async renameFile(fileInfo) {
        try {
            const filePath = StateManager.currentPath ? `${StateManager.currentPath}/${fileInfo.name}` : fileInfo.name;
            const encodedFilePath = encodeURIComponent(filePath);
            const newName = prompt('请输入新的文件名:', fileInfo.name);
            if (!newName || newName === fileInfo.name) return;
            if (!/^[a-zA-Z0-9_.-]+$/.test(newName)) {
                ToastManager.show('文件名只能包含字母、数字、下划线、点号和连字符');
                return;
            }
            const newPath = StateManager.currentPath ? `${StateManager.currentPath}/${newName}` : newName;
            const encodedNewPath = encodeURIComponent(newPath);
            ToastManager.show('正在重命名文件...');
            const fileResponse = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodedFilePath}`,
                { headers: { 'Authorization': `token ${StateManager.githubToken}`, 'Accept': 'application/vnd.github.v3+json' } }
            );
            if (!fileResponse.ok) {
                const errorData = await fileResponse.json();
                throw new Error(errorData.message || `获取文件失败: ${fileResponse.status}`);
            }
            const fileData = await fileResponse.json();
            const createResponse = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodedNewPath}`,
                {
                    method: 'PUT',
                    headers: { 'Authorization': `token ${StateManager.githubToken}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: `Rename ${fileInfo.name} to ${newName}`, content: fileData.content })
                }
            );
            if (!createResponse.ok) {
                const errorData = await createResponse.json();
                throw new Error(errorData.message || `创建新文件失败: ${createResponse.status}`);
            }
            const deleteResponse = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodedFilePath}`,
                {
                    method: 'DELETE',
                    headers: { 'Authorization': `token ${StateManager.githubToken}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: `Rename ${fileInfo.name} to ${newName}`, sha: fileData.sha })
                }
            );
            if (!deleteResponse.ok) {
                const errorData = await deleteResponse.json();
                throw new Error(errorData.message || `删除原文件失败: ${deleteResponse.status}`);
            }
            ToastManager.show('文件重命名成功');
            AutoRefreshManager.refreshAfterFileOperation();
        } catch (error) {
            console.error('重命名文件错误:', error);
            ToastManager.show('重命名文件失败: ' + error.message);
        }
    },
    // 重命名仓库
    async renameRepository(repoInfo) {
        try {
            const [owner, oldName] = repoInfo.path.split('/');
            const newName = prompt('请输入新的仓库名称:', oldName);
            if (!newName || newName === oldName) return;
            if (!/^[a-zA-Z0-9_.-]+$/.test(newName)) {
                ToastManager.show('仓库名称只能包含字母、数字、下划线、点号和连字符');
                return;
            }
            ToastManager.show('正在重命名仓库...');
            const response = await fetch(
                `https://api.github.com/repos/${owner}/${oldName}`,
                {
                    method: 'PATCH',
                    headers: { 'Authorization': `token ${StateManager.githubToken}`, 'Accept': 'application/vnd.github.v3+json', 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName })
                }
            );
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || '重命名失败');
            }
            ToastManager.show('仓库重命名成功');
            AutoRefreshManager.refreshWithCacheClear();
        } catch (error) {
            console.error('重命名仓库错误:', error);
            ToastManager.show('重命名失败: ' + error.message);
        }
    },
    // 复制文件链接
    copyFileLink(fileInfo, type) {
        if (fileInfo.type !== 'file') return;
        const rawUrl = fileInfo.download_url ||
            fileInfo.html_url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
        let link, successMessage;
        if (type === 'raw') { link = rawUrl; successMessage = 'Raw 链接已复制'; }
        else { link = `https://gh-proxy.com/${rawUrl}`; successMessage = '代理链接已复制'; }
        this.copyToClipboard(link, successMessage);
    },
    // 复制到剪贴板
    copyToClipboard(text, successMessage) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = 0;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            if (navigator.clipboard) navigator.clipboard.writeText(text).then(() => ToastManager.show(successMessage));
            else { document.execCommand('copy'); ToastManager.show(successMessage); }
        } catch (err) {
            console.error('复制失败:', err);
            ToastManager.show('复制失败: ' + err.message);
        } finally {
            document.body.removeChild(textArea);
        }
    },
    // 删除菜单项
    deleteContextItem(fileInfo) {
        if (fileInfo.type === 'repo') {
            DialogManager.showConfirmDialog(
                '确认删除仓库',
                `您确定要删除仓库 "${fileInfo.name}" 吗？此操作不可撤销且会删除所有仓库内容。`,
                fileInfo
            );
        } else {
            DialogManager.showConfirmDialog(
                '确认删除',
                `您确定要删除 "${fileInfo.name}" 吗？此操作不可撤销。`,
                fileInfo
            );
        }
    },
    // 下载仓库源码
    async downloadRepositorySource(repoInfo) {
        try {
            ToastManager.show(`正在准备下载 ${repoInfo.name} 仓库...`);
            const [owner, repo] = repoInfo.path.split('/');
            const repoData = await APIService.getRepositoryInfo(owner, repo);
            const defaultBranch = repoData.default_branch;
            const directDownloadSuccess = await this.tryDirectDownload(owner, repo, defaultBranch);
            if (directDownloadSuccess) {
                ToastManager.show(`仓库 ${repoInfo.name} 下载完成`);
                return;
            }
            await this.downloadViaAPI(owner, repo, defaultBranch, repoInfo.name);
        } catch (error) {
            console.error('下载仓库失败:', error);
            ToastManager.show('下载失败: ' + error.message);
            ToastManager.removeProgressToast();
        }
    },
    // 尝试直接下载仓库
    async tryDirectDownload(owner, repo, branch) {
        return new Promise((resolve) => {
            const testLink = document.createElement('a');
            testLink.href = `https://github.com/${owner}/${repo}/archive/refs/heads/${branch}.zip`;
            testLink.download = `${repo}-${branch}.zip`;
            const timeoutId = setTimeout(() => {
                document.body.removeChild(testLink);
                resolve(false);
            }, 5000);
            testLink.onclick = () => {
                clearTimeout(timeoutId);
                testLink.onclick = null;
                setTimeout(() => {
                    document.body.removeChild(testLink);
                    resolve(true);
                }, 100);
            };
            document.body.appendChild(testLink);
            testLink.click();
        });
    },
    // 通过API打包下载仓库
    async downloadViaAPI(owner, repo, branch, repoName) {
        const progressToast = ToastManager.createProgressToast('正在准备打包仓库内容...');
        try {
            progressToast.textContent = '正在扫描仓库文件...';
            const allFiles = await this.getAllFilesRecursive(owner, repo, branch, '');
            if (allFiles.length === 0) throw new Error('仓库为空，无法下载');
            progressToast.textContent = `正在打包 ${allFiles.length} 个文件...`;
            const zip = new JSZip();
            const folder = zip.folder(`${repo}-${branch}`);
            let count = 0;
            const updateProgress = () => progressToast.textContent = `打包进度: ${count}/${allFiles.length}`;
            const BATCH_SIZE = 10;
            for (let i = 0; i < allFiles.length; i += BATCH_SIZE) {
                const batch = allFiles.slice(i, i + BATCH_SIZE);
                await Promise.all(batch.map(async (file) => {
                    try {
                        const response = await fetch(file.download_url);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        const blob = await response.blob();
                        folder.file(file.path, blob);
                        count++;
                        updateProgress();
                    } catch (error) {
                        console.warn(`文件 ${file.path} 下载跳过:`, error);
                    }
                }));
            }
            progressToast.textContent = '正在生成压缩文件...';
            const content = await zip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 }
            }, updateProgress);
            const date = new Date().toISOString().slice(0, 10);
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = `${repo}-${branch}-${date}.zip`;
            link.click();
            setTimeout(() => {
                URL.revokeObjectURL(link.href);
                document.body.removeChild(link);
            }, 100);
            ToastManager.show(`仓库 ${repoName} 打包下载完成`);
        } finally {
            ToastManager.removeProgressToast();
        }
    },
    // 递归获取仓库所有文件
    async getAllFilesRecursive(owner, repo, branch, path) {
        try {
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`;
            const response = await fetch(url, {
                headers: { 'Authorization': `token ${StateManager.githubToken}`, 'Accept': 'application/vnd.github.v3+json' }
            });
            if (!response.ok) return [];
            const items = await response.json();
            const files = [];
            for (const item of items) {
                if (item.type === 'file') files.push({ path: item.path, download_url: item.download_url });
                else if (item.type === 'dir') files.push(...await this.getAllFilesRecursive(owner, repo, branch, item.path));
            }
            return files;
        } catch (error) {
            console.error('获取文件列表错误:', error);
            return [];
        }
    },
    // 切换GitHub Pages状态
    async toggleGitHubPages(fileInfo) {
        const { contextEnablePages } = DOMManager.elements;
        const originalHTML = contextEnablePages.innerHTML;
        contextEnablePages.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i><span>处理中...</span>';
        const targetRepo = this.getTargetRepo(fileInfo);
        const isEnabled = fileInfo.pagesEnabled === true;
        try {
            const [owner, repoName] = targetRepo.split('/');
            if (isEnabled) {
                await APIService.disableGitHubPages(owner, repoName);
                // 更新状态，确保菜单同步
                fileInfo.pagesEnabled = false;
                StateManager.pagesEnabledMap.set(targetRepo, false);
                ToastManager.show('网站已禁用');
                AutoRefreshManager.refreshAfterOperation();
                this.hide();
                setTimeout(() => this.updatePagesMenuButton(fileInfo, false), 500);
            } else {
                this.hide();
                setTimeout(() => {
                    StateManager.contextMenuTarget = fileInfo;
                    DialogManager.showStaticSiteDialog();
                }, 100);
            }
        } catch (error) {
            console.error('操作失败:', error);
            ToastManager.show(`操作失败: ${error.message}`);
            contextEnablePages.innerHTML = originalHTML;
        }
    },
    // 构建应用（触发工作流）
    async buildApp(repoInfo) {
        try {
            const [owner, repo] = repoInfo.path.split('/');
            const { buildStatus, buildIcon, buildMessage } = DOMManager.elements;
            buildStatus.classList.remove('hidden');
            buildIcon.className = 'fas fa-cog animate-spin text-blue-500 mr-2';
            buildMessage.textContent = '正在扫描工作流文件...';
            const workflowsResponse = await fetch(
                `https://api.github.com/repos/${owner}/${repo}/contents/.github/workflows`,
                { headers: { 'Authorization': `token ${StateManager.githubToken}`, 'Accept': 'application/vnd.github.v3+json' } }
            );
            if (!workflowsResponse.ok) throw new Error('获取工作流文件失败');
            const workflowFiles = await workflowsResponse.json();
            const validWorkflows = workflowFiles.filter(file => file.name.endsWith('.yml') || file.name.endsWith('.yaml'));
            if (validWorkflows.length === 0) throw new Error('未找到工作流文件');
            let selectedWorkflow = validWorkflows.find(file => file.name.toLowerCase().includes('build')) || validWorkflows[0];
            const workflowFileName = selectedWorkflow.name;
            buildMessage.textContent = `找到工作流: ${workflowFileName}`;
            const repoData = await APIService.getRepositoryInfo(owner, repo);
            const defaultBranch = repoData.default_branch;
            await APIService.triggerWorkflow(owner, repo, workflowFileName, defaultBranch);
            buildMessage.textContent = `工作流 ${workflowFileName} 已触发！监控进度中...`;
            this.monitorBuildProgress(owner, repo);
        } catch (error) {
            console.error('构建APP错误:', error);
            const { buildIcon, buildMessage } = DOMManager.elements;
            buildIcon.className = 'fas fa-times-circle text-red-500 mr-2';
            buildMessage.textContent = '构建失败: ' + error.message;
        }
    },
    // 监控构建进度
    async monitorBuildProgress(owner, repo) {
        clearInterval(StateManager.buildTimer);
        let progress = 0;
        const progressInterval = setInterval(() => {
            if (progress < 95) {
                progress += 5;
                DOMManager.elements.progressBar.style.width = `${progress}%`;
                DOMManager.elements.progressText.textContent = `${progress}%`;
            }
        }, 2000);
        StateManager.buildTimer = setInterval(async () => {
            try {
                const data = await APIService.getWorkflowRuns(owner, repo);
                const latestRun = data.workflow_runs[0];
                if (!latestRun) return;
                StateManager.buildStatus = latestRun.status;
                switch (latestRun.status) {
                    case 'completed':
                        clearInterval(progressInterval);
                        clearInterval(StateManager.buildTimer);
                        if (latestRun.conclusion === 'success') {
                            DOMManager.elements.progressBar.style.width = '100%';
                            DOMManager.elements.progressText.textContent = '100%';
                            DOMManager.elements.buildIcon.className = 'fas fa-check-circle text-green-500 mr-2';
                            const artifactsResponse = await fetch(latestRun.artifacts_url, {
                                headers: { 'Authorization': `token ${StateManager.githubToken}`, 'Accept': 'application/vnd.github.v3+json' }
                            });
                            if (artifactsResponse.ok) {
                                const artifactsData = await artifactsResponse.json();
                                if (artifactsData.artifacts.length > 0) {
                                    const artifactLinks = artifactsData.artifacts.map(a =>
                                        `<a href="${a.archive_download_url}" target="_blank" class="text-blue-500">${a.name}</a>`
                                    ).join('<br>');
                                    DOMManager.elements.buildMessage.innerHTML = `构建成功！下载制品:<br>${artifactLinks}`;
                                } else {
                                    DOMManager.elements.buildMessage.innerHTML = '构建成功！<br>可在仓库的Actions页面查看详情';
                                }
                            } else {
                                DOMManager.elements.buildMessage.innerHTML = '构建成功！<br>可在仓库的Actions页面查看详情';
                            }
                        } else {
                            DOMManager.elements.buildIcon.className = 'fas fa-times-circle text-red-500 mr-2';
                            DOMManager.elements.buildMessage.textContent = `构建失败: ${latestRun.conclusion}`;
                        }
                        break;
                    case 'in_progress':
                        DOMManager.elements.buildMessage.textContent = '构建正在进行中...';
                        break;
                    case 'queued':
                        DOMManager.elements.buildMessage.textContent = '构建任务排队中...';
                        break;
                }
            } catch (error) {
                console.error('监控构建进度错误:', error);
                clearInterval(progressInterval);
                clearInterval(StateManager.buildTimer);
                DOMManager.elements.buildIcon.className = 'fas fa-times-circle text-red-500 mr-2';
                DOMManager.elements.buildMessage.textContent = '监控失败: ' + error.message;
            }
        }, 10000);
    },
    // 显示搜索结果上下文菜单
    showSearchContextMenu(e, repoInfo) {
        e.preventDefault();
        e.stopPropagation();
        this.show(e, repoInfo, true);
    },
    // 隐藏搜索结果上下文菜单
    hideSearchContextMenu() {
        const mask = document.getElementById('search-context-menu-mask');
        if (mask) mask.remove();
        const menu = DOMManager.elements.searchContextMenu;
        menu.classList.remove('visible');
        menu.style.left = '-9999px';
        menu.style.top = '-9999px';
        StateManager.contextMenuTarget = null;
        StateManager.isSearchContextMenu = false;
    },
    // 处理搜索结果菜单点击
    handleSearchMenuItemClick(action) {
        if (!StateManager.contextMenuTarget) return;
        const repoInfo = StateManager.contextMenuTarget;
        switch (action) {
            case 'fork': this.forkRepository(repoInfo); break;
            case 'copy-link': this.copyRepoLink(repoInfo); break;
            case 'copy-site-link': this.copySiteLink(repoInfo); break;
            case 'visit': this.openContextItem(repoInfo); break;
        }
        this.hide();
        this.hideSearchContextMenu();
    },
    // 复刻仓库
    async forkRepository(repoInfo) {
        try {
            const [owner, repo] = repoInfo.path.split('/');
            ToastManager.show(`正在复刻仓库 ${repo}...`);
            await APIService.forkRepository(owner, repo);
            ToastManager.show('仓库复刻成功，刷新后查看');
            AutoRefreshManager.refreshWithCacheClear();
        } catch (error) {
            console.error('复刻仓库错误:', error);
            ToastManager.show('复刻失败: ' + error.message);
        }
    },
    // 显示搜索结果文件上下文菜单
    showSearchFileContextMenu(e, fileInfo) {
        e.preventDefault();
        e.stopPropagation();
        const oldMask = document.getElementById('search-file-context-menu-mask');
        if (oldMask) oldMask.remove();
        const mask = document.createElement('div');
        mask.id = 'search-file-context-menu-mask';
        mask.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            z-index: 999;
        `;
        document.body.appendChild(mask);
        StateManager.contextMenuTarget = fileInfo;
        const { searchFileContextMenu } = DOMManager.elements;
        if (searchFileContextMenu) {
            this.positionSearchFileMenu(e, searchFileContextMenu);
            searchFileContextMenu.classList.add('visible');
        }
        mask.addEventListener('click', () => this.hideSearchFileContextMenu());
    },
    // 定位搜索结果文件菜单
    positionSearchFileMenu(e, menu) {
        const menuWidth = menu.offsetWidth;
        const menuHeight = menu.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        let posX = e.clientX;
        let posY = e.clientY;
        if (posX + menuWidth > viewportWidth) posX = viewportWidth - menuWidth - 10;
        if (posY + menuHeight > viewportHeight) posY = viewportHeight - menuHeight - 10;
        menu.style.left = `${Math.max(10, posX)}px`;
        menu.style.top = `${Math.max(10, posY)}px`;
    },
    // 隐藏搜索结果文件上下文菜单
    hideSearchFileContextMenu() {
        const mask = document.getElementById('search-file-context-menu-mask');
        if (mask) mask.remove();
        const menu = DOMManager.elements.searchFileContextMenu;
        menu.classList.remove('visible');
        menu.style.left = '-9999px';
        menu.style.top = '-9999px';
        StateManager.contextMenuTarget = null;
    },
    // 处理搜索结果文件菜单点击
    handleSearchFileMenuItemClick(action) {
        if (!StateManager.contextMenuTarget) return;
        const fileInfo = StateManager.contextMenuTarget;
        switch (action) {
            case 'open': this.openSearchFile(fileInfo); break;
            case 'download': this.downloadSearchFile(fileInfo); break;
            case 'copy-link': this.copySearchFileLink(fileInfo, 'raw'); break;
            case 'copy-proxy-link': this.copySearchFileLink(fileInfo, 'cdn'); break;
        }
        this.hideSearchFileContextMenu();
    },
    // 打开搜索结果文件
    openSearchFile(fileInfo) {
        if (fileInfo.type === 'dir') {
            NavigationManager.loadRepositoryContents(
                StateManager.currentRepo,
                `${StateManager.currentPath ? StateManager.currentPath + '/' : ''}${fileInfo.name}`
            );
        } else if (fileInfo.type === 'file') {
            FileManager.handleFileOpen(fileInfo);
        }
    },
    // 下载搜索结果文件
    downloadSearchFile(fileInfo) {
        if (fileInfo.type === 'file' && fileInfo.download_url) {
            FileManager.downloadFile(fileInfo);
        }
    },
    // 复制搜索结果文件链接
    copySearchFileLink(fileInfo, type) {
        if (fileInfo.type !== 'file') return;
        let link, successMessage;
        if (type === 'raw') { link = fileInfo.download_url; successMessage = 'Raw 链接已复制'; }
        else { link = `https://gh-proxy.com/${fileInfo.download_url}`; successMessage = '代理链接已复制'; }
        this.copyToClipboard(link, successMessage);
    },
    // 绑定搜索结果文件菜单事件
    bindSearchFileContextMenuEvents() {
        const { searchFileOpen, searchFileDownload, searchFileCopyLink, searchFileCopyProxyLink } = DOMManager.elements;
        searchFileOpen?.addEventListener('click', () => this.handleSearchFileMenuItemClick('open'));
        searchFileDownload?.addEventListener('click', () => this.handleSearchFileMenuItemClick('download'));
        searchFileCopyLink?.addEventListener('click', () => this.handleSearchFileMenuItemClick('copy-link'));
        searchFileCopyProxyLink?.addEventListener('click', () => this.handleSearchFileMenuItemClick('copy-proxy-link'));
    },
    // 全局点击处理（隐藏菜单）
    handleGlobalClick(e) {
        const { contextMenu, searchContextMenu, searchFileContextMenu } = DOMManager.elements;
        const isMenuClick = contextMenu.contains(e.target) ||
                           searchContextMenu.contains(e.target) ||
                           searchFileContextMenu.contains(e.target);
        if (!isMenuClick) {
            this.hide();
            this.hideSearchContextMenu();
            this.hideSearchFileContextMenu();
        }
    },
    // 绑定所有上下文菜单事件
    bindContextMenuEvents() {
        const {
            contextOpen, contextDownload, contextRename,
            contextCopyLink, contextCopyProxyLink, contextDelete,
            contextEnablePages, contextBuildApp, contextDownloadSource,
            contextCopyRepoLink, contextCopySiteLink,
            contextRenameRepo
        } = DOMManager.elements;
        contextOpen?.addEventListener('click', () => this.handleMenuItemClick('open'));
        contextDownload?.addEventListener('click', () => this.handleMenuItemClick('download'));
        contextRename?.addEventListener('click', () => this.handleMenuItemClick('rename'));
        contextCopyLink?.addEventListener('click', () => this.handleMenuItemClick('copy-link'));
        contextCopyProxyLink?.addEventListener('click', () => this.handleMenuItemClick('copy-proxy-link'));
        contextCopyRepoLink?.addEventListener('click', () => this.handleMenuItemClick('copy-repo-link'));
        contextCopySiteLink?.addEventListener('click', () => this.handleMenuItemClick('copy-site-link'));
        contextRenameRepo?.addEventListener('click', () => this.handleMenuItemClick('rename-repo'));
        contextDelete?.addEventListener('click', () => this.handleMenuItemClick('delete'));
        contextDownloadSource?.addEventListener('click', () => this.handleMenuItemClick('download-source'));
        contextEnablePages?.addEventListener('click', () => this.handleMenuItemClick('enable-pages'));
        contextBuildApp?.addEventListener('click', () => this.handleMenuItemClick('build-app'));
        this.bindSearchFileContextMenuEvents();
        document.removeEventListener('click', this.handleGlobalClick.bind(this));
        document.addEventListener('click', this.handleGlobalClick.bind(this));
    }
};

// ==================== 补充：修改 NavigationManager 关联方法 ====================
const originalLoadSearchResults = NavigationManager.loadSearchResults;
NavigationManager.loadSearchResults = async function(query, page = 1, useCache = true) {
    ContextMenuManager.setIsSearchResultPage(true);
    return originalLoadSearchResults.call(this, query, page, useCache);
};
const originalLoadRepositories = NavigationManager.loadRepositories;
NavigationManager.loadRepositories = async function(useCache = true) {
    ContextMenuManager.setIsSearchResultPage(false);
    return originalLoadRepositories.call(this, useCache);
};

// ==================== 认证管理模块 ====================
const AuthManager = {
    // 检查本地存储中的 Token - 唯一实现
    checkStoredToken() {
        const savedToken = localStorage.getItem('github_token');
        if (savedToken && savedToken.length === 40) {
            // 直接设置 token 到状态管理器
            StateManager.githubToken = savedToken;
            StateManager.setToken(savedToken); // 确保调用 setToken 方法
            
            // 隐藏输入框中的 token 显示
            DOMManager.elements.githubTokenInput.value = '********';
            
            // 立即验证 token 有效性
            this.verifyToken(savedToken);
            return true;
        }
        return false;
    },
    // 验证 Token - 优化版本
    async verifyToken(token) {
        try {
            // 显示加载状态
            const { authBtnText, authSpinner, authBtn } = DOMManager.elements;
            authBtnText.textContent = '认证中...';
            authSpinner.classList.remove('hidden');
            authBtn.disabled = true;
            
            // 设置超时
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);
            
            // 发送验证请求
            const userData = await APIService.verifyToken(token);
            
            clearTimeout(timeoutId);
            
            // 认证成功
            StateManager.setToken(token);
            StateManager.currentUser = userData;
            
            ToastManager.show(`欢迎回来: ${userData.login || '用户'}！`);
            DOMManager.showMainScreen();
            
            // 更新用户信息
            DOMManager.elements.username.textContent = userData.login;
            
            // 认证成功后初始化页面状态
            App.initializePageState();
            
        } catch (error) {
            console.error('认证错误:', error);
            
            let errorMessage = error.message;
            if (error.name === 'AbortError') {
                errorMessage = '请求超时，请检查网络连接';
            }
            
            // 认证失败时清除无效的 token
            if (errorMessage.includes('认证失败') || errorMessage.includes('Bad credentials')) {
                this.clearInvalidToken();
            }
            
            this.showTokenError(errorMessage);
            ToastManager.show(errorMessage);
            
        } finally {
            const { authBtnText, authSpinner, authBtn } = DOMManager.elements;
            authBtnText.textContent = '认证并继续';
            authSpinner.classList.add('hidden');
            authBtn.disabled = false;
        }
    },
    // 清除无效的 token
    clearInvalidToken() {
        StateManager.clearToken();
        DOMManager.elements.githubTokenInput.value = '';
        DOMManager.elements.tokenError.classList.add('hidden');
    },
    // 显示 Token 错误
    showTokenError(message) {
        const { tokenError } = DOMManager.elements;
        tokenError.textContent = message;
        tokenError.classList.remove('hidden');
    },
    // 退出登录
    logout() {
        StateManager.clearToken();
        StateManager.currentUser = null;
        DOMManager.showAuthScreen();
        const { githubTokenInput, tokenError } = DOMManager.elements;
        githubTokenInput.value = '';
        tokenError.classList.add('hidden');
        ToastManager.show('已退出登录');
    }
};

// ==================== 提示管理模块 ====================
const ToastManager = {
    // 显示提示
    show(message) {
        const { toast } = DOMManager.elements;
        if (!toast) return;
        
        toast.textContent = message;
        toast.classList.remove('opacity-0');
        toast.classList.add('opacity-100');
        
        setTimeout(() => {
            toast.classList.remove('opacity-100');
            toast.classList.add('opacity-0');
        }, 3000);
    },

    // 创建进度提示
    createProgressToast(text) {
        this.removeProgressToast();
        
        const toast = document.createElement('div');
        toast.id = 'progress-toast';
        toast.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 glass-panel px-6 py-3 rounded-full text-sm font-medium';
        toast.textContent = text;
        document.body.appendChild(toast);
        return toast;
    },

    // 移除进度提示
    removeProgressToast() {
        const existing = document.getElementById('progress-toast');
        if (existing) document.body.removeChild(existing);
    }
};

// ==================== 应用主模块 ====================
const App = {
    // 初始化应用
    init() {
        // 添加错误处理
        window.addEventListener('error', (e) => {
            console.error('全局错误:', e.error);
            ToastManager.show('应用出现错误，请刷新页面');
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('未处理的Promise拒绝:', e.reason);
            ToastManager.show('应用出现异步错误，请刷新页面');
        });
        DOMManager.init();
        const hasValidToken = AuthManager.checkStoredToken();
        
        if (!hasValidToken) {
            DOMManager.showAuthScreen();
        }
        
        this.bindEventListeners();
        SearchManager.init();
        
        // 初始化搜索排序状态（新增）
        StateManager.setSearchSort('updated');
        
        // 修复：确保popstate事件正确绑定
        window.addEventListener('popstate', (event) => {
            NavigationManager.handlePopState(event);
        });
        
        // 修复：确保页面加载时正确初始化状态
        window.addEventListener('load', () => {
            // 延迟执行确保DOM完全加载
            setTimeout(() => {
                const state = NavigationManager.parseURL();
                console.log('页面加载，导航到状态:', state);
                NavigationManager.navigateToState(state.type, state.data);
            }, 100);
        });
        
        // 修复：如果已经有token，立即初始化页面状态
        if (StateManager.githubToken) {
            EditorManager.init().catch(() => {});
            
            // 延迟初始化页面状态
            setTimeout(() => {
                const state = NavigationManager.parseURL();
                NavigationManager.navigateToState(state.type, state.data);
            }, 200);
        }
    },

    // 初始化页面状态 - 确保在认证完成后调用
    initializePageState() {
        console.log('初始化页面状态，当前Token:', StateManager.githubToken ? '存在' : '不存在');
        
        // 延迟执行以确保DOM完全加载
        setTimeout(() => {
            const state = NavigationManager.parseURL();
            console.log('导航到状态:', state);
            NavigationManager.navigateToState(state.type, state.data);
        }, 100);
    },

    // 绑定事件监听器（修复方法结构）
    bindEventListeners() {
        const {
            // 认证界面
            authBtn, githubTokenInput,
            // 主界面工具栏
            newRepoBtn, forkRepoBtn, newFolderBtn, uploadBtn, selectBtn, staticSiteBtn,
            // 用户菜单
            userMenuBtn, logoutBtn,
            // 批量操作
            batchDownloadBtn, batchDeleteBtn, batchCancelBtn,
            // 编辑器
            editorSaveBtn, editorCloseBtn,
            // 移动设备工具栏
            mobileSaveBtn, mobileCloseBtn, mobileUndoBtn, mobileRedoBtn, mobileSearchBtn,
            // 对话框
            confirmYes, confirmNo,
            newFolderCreate, newFolderCancel, newRepoCreate, newRepoCancel,
            uploadFile, uploadCancel, staticSiteEnable, staticSiteCancel,
            forkRepoConfirm, forkRepoCancel,
            // 构建状态
            closeBuildStatus,
            // 搜索相关元素
            searchRepoBtn,
            searchContextFork,
            searchContextCopyLink,
            searchContextVisit,
            // 版本列表关键元素
            releasesLoading,
            releasesEmpty,
            refreshReleasesBtn,
            // 搜索文件上下文菜单元素
            searchFileOpen,
            searchFileDownload,
            searchFileCopyLink,
            searchFileCopyProxyLink
        } = DOMManager.elements;
        
        // 确保版本列表元素存在
        if (!releasesLoading || !releasesEmpty || !refreshReleasesBtn) {
            console.warn('版本列表相关元素未找到，可能影响版本显示功能');
        }
        
        // 认证相关
        authBtn?.addEventListener('click', () => {
            const token = githubTokenInput.value.trim();
            if (!token) {
                AuthManager.showTokenError('请输入 GitHub Token');
                return;
            }
            if (token.length !== 40) {
                AuthManager.showTokenError('Token 应为 40 位字符');
                return;
            }
            AuthManager.verifyToken(token);
        });
        
        // 工具栏按钮
        newRepoBtn?.addEventListener('click', () => DialogManager.showNewRepoDialog());
        forkRepoBtn?.addEventListener('click', () => DialogManager.showForkRepoDialog());
        newFolderBtn?.addEventListener('click', () => DialogManager.showNewFolderDialog());
        uploadBtn?.addEventListener('click', () => DialogManager.showUploadDialog());
        selectBtn?.addEventListener('click', () => SelectionManager.toggleSelectMode());
        staticSiteBtn?.addEventListener('click', () => DialogManager.showStaticSiteDialog());
        
        // 用户菜单
        userMenuBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            DOMManager.elements.userMenuContent.classList.toggle('show');
        });
        
        logoutBtn?.addEventListener('click', () => AuthManager.logout());
        
        // 点击其他地方隐藏用户菜单
        document.addEventListener('click', () => {
            DOMManager.elements.userMenuContent?.classList.remove('show');
        });
        
        // 批量操作
        batchDownloadBtn?.addEventListener('click', () => SelectionManager.downloadSelectedFiles());
        batchDeleteBtn?.addEventListener('click', () => SelectionManager.deleteSelectedFiles());
        batchCancelBtn?.addEventListener('click', () => SelectionManager.exitSelectMode());
        
        // 编辑器
        editorSaveBtn?.addEventListener('click', () => EditorManager.saveFileChanges());
        editorCloseBtn?.addEventListener('click', () => EditorManager.closeEditor());
        
        // 移动设备工具栏
        mobileSaveBtn?.addEventListener('click', () => EditorManager.saveFileChanges());
        mobileCloseBtn?.addEventListener('click', () => EditorManager.closeEditor());
        mobileUndoBtn?.addEventListener('click', () => {
            if (StateManager.editor) StateManager.editor.getModel().undo();
        });
        mobileRedoBtn?.addEventListener('click', () => {
            if (StateManager.editor) StateManager.editor.getModel().redo();
        });
        mobileSearchBtn?.addEventListener('click', () => {
            if (StateManager.editor) {
                StateManager.editor.focus();
                StateManager.editor.trigger('', 'actions.find');
            }
        });
        
        // 确认对话框
        confirmYes?.addEventListener('click', () => this.handleConfirmYes());
        confirmNo?.addEventListener('click', () => DialogManager.hideConfirmDialog());
        
        // 新建文件夹对话框
        newFolderCreate?.addEventListener('click', () => this.handleNewFolderCreate());
        newFolderCancel?.addEventListener('click', () => DialogManager.hideNewFolderDialog());
        
        // 新建仓库对话框
        newRepoCreate?.addEventListener('click', () => this.handleNewRepoCreate());
        newRepoCancel?.addEventListener('click', () => DialogManager.hideNewRepoDialog());
        
        // 上传文件对话框
        uploadFile?.addEventListener('click', () => this.handleFileUpload());
        uploadCancel?.addEventListener('click', () => DialogManager.hideUploadDialog());
        
        // 部署网站对话框
        staticSiteEnable?.addEventListener('click', () => this.enableGitHubPages());
        staticSiteCancel?.addEventListener('click', () => DialogManager.hideStaticSiteDialog());
        
        // 复刻仓库对话框
        forkRepoConfirm?.addEventListener('click', () => this.handleForkRepo());
        forkRepoCancel?.addEventListener('click', () => DialogManager.hideForkRepoDialog());
        
        // 构建状态
        closeBuildStatus?.addEventListener('click', () => this.closeBuildStatus());
        
        // 上下文菜单事件绑定
        this.bindContextMenuEvents();
        
        // 对话框遮罩层事件绑定
        this.bindDialogMaskEvents();
        
        // 搜索按钮点击事件（唯一绑定）
        searchRepoBtn?.addEventListener('click', () => {
            SearchManager.openSearchOverlay();
        });
        
        // 搜索结果上下文菜单事件
        searchContextFork?.addEventListener('click', () => {
            ContextMenuManager.handleSearchMenuItemClick('fork');
        });
        searchContextCopyLink?.addEventListener('click', () => {
            ContextMenuManager.handleSearchMenuItemClick('copy-link');
        });
        searchContextVisit?.addEventListener('click', () => {
            ContextMenuManager.handleSearchMenuItemClick('visit');
        });
        
        // 绑定搜索上下文菜单事件
        ContextMenuManager.bindSearchContextMenuEvents();
        
        // 搜索文件上下文菜单事件
        searchFileOpen?.addEventListener('click', () => {
            ContextMenuManager.handleSearchFileMenuItemClick('open');
        });
        searchFileDownload?.addEventListener('click', () => {
            ContextMenuManager.handleSearchFileMenuItemClick('download');
        });
        searchFileCopyLink?.addEventListener('click', () => {
            ContextMenuManager.handleSearchFileMenuItemClick('copy-link');
        });
        searchFileCopyProxyLink?.addEventListener('click', () => {
            ContextMenuManager.handleSearchFileMenuItemClick('copy-proxy-link');
        });
        
        // 刷新版本列表（单一绑定，移除重复绑定）
        refreshReleasesBtn?.addEventListener('click', () => {
            if (StateManager.currentRepo) {
                const [owner, repoName] = StateManager.currentRepo.split('/');
                DOMManager.show(releasesLoading);
                APIService.getRepositoryReleases(owner, repoName)
                    .then(releases => DOMManager.renderReleases(releases))
                    .catch(error => {
                        console.error('刷新版本列表错误:', error);
                        DOMManager.hide(releasesLoading);
                        DOMManager.show(releasesEmpty);
                        ToastManager.show('刷新版本失败: ' + error.message);
                    });
            }
        });
        
        // 返回按钮支持
        const backBtn = document.getElementById('back-btn');
        if (backBtn) {
            backBtn.addEventListener('click', () => NavigationManager.goBack());
        }
        
        // 键盘返回支持（ESC键）
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !StateManager.currentEditingFile) {
                NavigationManager.goBack();
            }
        });
        
        // 移动端手势返回支持
        let touchStartX = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });
        document.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].screenX;
            const diffX = touchEndX - touchStartX;
            if (diffX > 100 && touchStartX < 50) {
                NavigationManager.goBack();
            }
        });
    },

    // 绑定上下文菜单事件（独立方法）
    bindContextMenuEvents() {
        const {
            contextOpen, contextDownload, contextRename,
            contextCopyLink, contextCopyProxyLink, contextDelete,
            contextEnablePages, contextBuildApp, contextDownloadSource,
            contextCopyRepoLink, contextCopySiteLink,
            contextRenameRepo
        } = DOMManager.elements;
        
        contextOpen?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('open'));
        contextDownload?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('download'));
        contextRename?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('rename'));
        contextCopyLink?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('copy-link'));
        contextCopyProxyLink?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('copy-proxy-link'));
        contextCopyRepoLink?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('copy-repo-link'));
        contextCopySiteLink?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('copy-site-link'));
        contextRenameRepo?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('rename-repo'));
        contextDelete?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('delete'));
        contextDownloadSource?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('download-source'));
        contextEnablePages?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('enable-pages'));
        contextBuildApp?.addEventListener('click', () => ContextMenuManager.handleMenuItemClick('build-app'));
        
        // 点击其他地方隐藏上下文菜单
        document.addEventListener('click', () => ContextMenuManager.hide());
    },

    // 绑定对话框遮罩层事件（独立方法）
    bindDialogMaskEvents() {
        const dialogs = [
            'confirm-dialog', 'new-folder-dialog', 'new-repo-dialog',
            'fork-repo-dialog', 'upload-dialog', 'static-site-dialog'
        ];
        
        dialogs.forEach(dialogId => {
            const dialog = document.getElementById(dialogId);
            if (dialog) {
                dialog.addEventListener('click', (e) => {
                    if (e.target === dialog) {
                        DialogManager.hideDialog(dialog);
                    }
                });
            }
        });
    },

    // 处理确认对话框的确认操作
async handleConfirmYes() {
    if (StateManager.fileToDelete) {
        if (Array.isArray(StateManager.fileToDelete)) {
            await this.deleteFiles(StateManager.fileToDelete);
            AutoRefreshManager.refreshAfterFileOperation(); // 改为增强版
        } else if (StateManager.fileToDelete.type === 'repo') {
            await this.deleteRepository(StateManager.fileToDelete);
            AutoRefreshManager.refreshAfterRepoOperation(); // 改为增强版
        } else {
            await this.deleteFile(StateManager.fileToDelete);
            AutoRefreshManager.refreshAfterFileOperation(); // 改为增强版
        }
    }
    DialogManager.hideConfirmDialog();
},

    // 删除文件或文件夹
    async deleteFile(fileInfo) {
        try {
            // 如果是文件夹，需要递归删除
            if (fileInfo.type === 'dir') {
                await this.deleteFolderRecursive(fileInfo);
                return;
            }
            // 以下是原有的文件删除逻辑
            const filePath = StateManager.currentPath ?
                `${StateManager.currentPath}/${fileInfo.name}` : fileInfo.name;
            
            // 获取文件SHA
            const fileData = await this.getFileInfoIfExists(filePath);
            
            if (!fileData || !fileData.sha) {
                throw new Error('无法获取文件SHA，文件可能不存在');
            }
            // 删除文件
            const response = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
                {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Delete ${fileInfo.name}`,
                        sha: fileData.sha
                    })
                }
            );
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `删除失败: ${response.status}`);
            }
            ToastManager.show('文件删除成功');
            NavigationManager.loadRepositoryContents(StateManager.currentRepo, StateManager.currentPath);
            
        } catch (error) {
            console.error('删除文件错误:', error);
            ToastManager.show('删除文件失败: ' + error.message);
        }
    },

    // 递归删除文件夹
    async deleteFolderRecursive(folderInfo) {
        try {
            ToastManager.show(`正在删除文件夹 ${folderInfo.name}...`);
            
            // 获取文件夹内容
            const folderPath = StateManager.currentPath ?
                `${StateManager.currentPath}/${folderInfo.name}` : folderInfo.name;
            
            const contents = await APIService.getRepositoryContents(StateManager.currentRepo, folderPath);
            
            if (contents.length === 0) {
                // 空文件夹，删除 .gitkeep 文件（如果存在）
                await this.deleteGitKeepFile(folderPath);
                ToastManager.show('空文件夹删除成功');
                NavigationManager.loadRepositoryContents(StateManager.currentRepo, StateManager.currentPath);
                return;
            }
            // 递归删除所有内容
            let successCount = 0;
            let failCount = 0;
            for (const item of contents) {
                try {
                    // 构建完整路径
                    const fullPath = `${folderPath}/${item.name}`;
                    
                    if (item.type === 'dir') {
                        // 递归删除子文件夹
                        await this.deleteFolderRecursive({
                            ...item,
                            name: fullPath.split('/').pop()
                        });
                    } else {
                        // 删除文件
                        await this.deleteFileInPath(fullPath, item.name);
                    }
                    successCount++;
                } catch (error) {
                    console.error(`删除 ${item.name} 失败:`, error);
                    failCount++;
                }
            }
            // 最后删除文件夹本身（通过删除.gitkeep文件）
            await this.deleteGitKeepFile(folderPath);
            if (failCount === 0) {
                ToastManager.show(`文件夹 ${folderInfo.name} 删除成功`);
            } else {
                ToastManager.show(`文件夹删除完成: ${successCount} 成功, ${failCount} 失败`);
            }
            NavigationManager.loadRepositoryContents(StateManager.currentRepo, StateManager.currentPath);
            
        } catch (error) {
            console.error('删除文件夹错误:', error);
            throw error;
        }
    },

    // 删除路径中的文件
    async deleteFileInPath(filePath, fileName) {
        const fileData = await this.getFileInfoIfExists(filePath);
        
        if (!fileData || !fileData.sha) {
            throw new Error(`无法获取文件SHA: ${fileName}`);
        }
        const response = await fetch(
            `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
            {
                method: 'DELETE',
                headers: {
                    'Authorization': `token ${StateManager.githubToken}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message: `Delete ${fileName}`,
                    sha: fileData.sha
                })
            }
        );
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `删除失败: ${response.status}`);
        }
    },

    // 删除.gitkeep文件（用于标记空文件夹）
    async deleteGitKeepFile(folderPath) {
        const gitkeepPath = `${folderPath}/.gitkeep`;
        
        try {
            const gitkeepData = await this.getFileInfoIfExists(gitkeepPath);
            if (gitkeepData && gitkeepData.sha) {
                await this.deleteFileInPath(gitkeepPath, '.gitkeep');
            }
        } catch (error) {
            // .gitkeep文件不存在是正常的，忽略错误
            console.log('.gitkeep文件不存在，跳过删除');
        }
    },

    // 批量删除文件
    async deleteFiles(files) {
        try {
            let successCount = 0;
            let failCount = 0;
            
            for (const file of files) {
                try {
                    if (file.type === 'dir') {
                        // 递归删除文件夹
                        await this.deleteFolderRecursive(file);
                    } else {
                        // 删除文件
                        const filePath = StateManager.currentPath ?
                            `${StateManager.currentPath}/${file.name}` : file.name;
                        
                        const fileData = await this.getFileInfoIfExists(filePath);
                        
                        if (!fileData || !fileData.sha) {
                            console.warn(`文件 ${file.name} 不存在，跳过删除`);
                            failCount++;
                            continue;
                        }
                        await this.deleteFileInPath(filePath, file.name);
                    }
                    successCount++;
                } catch (error) {
                    console.error(`删除 ${file.name} 失败:`, error);
                    failCount++;
                }
            }
            
            if (failCount === 0) {
                ToastManager.show(`成功删除 ${successCount} 个项目`);
            } else {
                ToastManager.show(`删除完成: ${successCount} 成功, ${failCount} 失败`);
            }
            
            SelectionManager.exitSelectMode();
            NavigationManager.loadRepositoryContents(StateManager.currentRepo, StateManager.currentPath);
            
        } catch (error) {
            console.error('批量删除错误:', error);
            ToastManager.show('批量删除失败: ' + error.message);
        }
    },

    // 删除仓库
    async deleteRepository(repoInfo) {
        try {
            const [owner, repoName] = repoInfo.path.split('/');
            
            await APIService.deleteRepository(owner, repoName);
            
            ToastManager.show('仓库删除成功');
            NavigationManager.loadRepositories();
            
        } catch (error) {
            console.error('删除仓库错误:', error);
            ToastManager.show('删除仓库失败: ' + error.message);
        }
    },

    // 处理新建文件夹
    async handleNewFolderCreate() {
        const folderNameInput = DOMManager.elements.newFolderName;
        const folderName = folderNameInput.value.trim();
        
        if (!folderName) {
            ToastManager.show('请输入文件夹名称');
            folderNameInput.focus();
            return;
        }
        // 验证文件夹名称格式
        if (!/^[a-zA-Z0-9_.-]+$/.test(folderName)) {
            ToastManager.show('文件夹名称只能包含字母、数字、下划线、点号和连字符');
            folderNameInput.focus();
            return;
        }
        try {
            // 显示创建中状态
            const createBtn = DOMManager.elements.newFolderCreate;
            const originalText = createBtn.innerHTML;
            createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 创建中...';
            createBtn.disabled = true;
            await this.createFolder(folderName);
            DialogManager.hideNewFolderDialog();
            
        } catch (error) {
            console.error('处理新建文件夹错误:', error);
        } finally {
            // 恢复按钮状态
            const createBtn = DOMManager.elements.newFolderCreate;
            createBtn.innerHTML = '创建';
            createBtn.disabled = false;
        }
    },

    // 创建文件夹
    async createFolder(folderName) {
        try {
            // 验证文件夹名称
            if (!folderName || folderName.trim() === '') {
                throw new Error('文件夹名称不能为空');
            }
            // 清理文件夹名称
            folderName = folderName.trim().replace(/[\/\\]/g, '');
            
            // 构建文件路径
            const filePath = StateManager.currentRepo ?
                `${StateManager.currentRepo}/${folderName}/.gitkeep` : `${folderName}/.gitkeep`;
            
            console.log('创建文件夹:', {
                repo: StateManager.currentRepo,
                path: filePath,
                token: StateManager.githubToken ? '有Token' : '无Token'
            });
            // 直接使用 fetch 确保认证头正确传递
            const base64Content = btoa(unescape(encodeURIComponent(''))); // 空内容
            
            const response = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Create folder ${folderName}`,
                        content: base64Content
                    })
                }
            );
            console.log('API响应状态:', response.status);
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('API错误详情:', errorData);
                
                if (response.status === 401) {
                    throw new Error('认证失败: Token 无效或已过期，请重新登录');
                } else if (response.status === 403) {
                    throw new Error('权限不足: Token 缺少 repo 权限或已达到 API 限制');
                } else if (response.status === 404) {
                    throw new Error('仓库不存在或没有访问权限');
                } else if (response.status === 422) {
                    // 文件已存在的情况
                    if (errorData.message && errorData.message.includes('already exists')) {
                        throw new Error(`文件夹 "${folderName}" 已存在`);
                    }
                    throw new Error(errorData.message || '创建失败: 验证错误');
                } else {
                    throw new Error(errorData.message || `创建失败: ${response.status}`);
                }
            }
            const result = await response.json();
            console.log('创建成功:', result);
            
            ToastManager.show(`文件夹 "${folderName}" 创建成功`);
            
            // 创建文件夹后刷新当前目录
            AutoRefreshManager.refreshAfterFileOperation();
            
        } catch (error) {
            console.error('创建文件夹错误:', error);
            
            // 更详细的错误处理
            if (error.message.includes('认证失败') || error.message.includes('权限不足')) {
                ToastManager.show(error.message);
                // 如果是认证问题，建议重新登录
                setTimeout(() => {
                    if (confirm('认证失败，是否重新登录？')) {
                        AuthManager.logout();
                    }
                }, 1000);
            } else {
                ToastManager.show('创建文件夹失败: ' + error.message);
            }
        }
    },

    // 创建仓库方法 - 简化版本
    createRepository: async function(name, description, isPrivate) {
        try {
            ToastManager.show('正在创建仓库...');
            // 调用 APIService 创建仓库（正确逻辑）
            const result = await APIService.createRepository(name, description, isPrivate);
            
            ToastManager.show(`仓库 "${name}" 创建成功`);
StateManager.clearDirectoryCache('repositories', '');
// 新建仓库后刷新仓库列表
AutoRefreshManager.refreshAfterRepoOperation(); 
            
            return result;
        } catch (error) {
            console.error('创建仓库错误:', error);
            ToastManager.show('创建仓库失败: ' + error.message);
            throw error;
        }
    },

    // 处理新建仓库
    async handleNewRepoCreate() {
        const repoName = DOMManager.elements.newRepoName.value.trim();
        const repoDesc = DOMManager.elements.newRepoDesc.value.trim();
        const isPrivate = DOMManager.elements.newRepoPrivate.checked;
        
        if (!repoName) {
            ToastManager.show('请输入仓库名称');
            DOMManager.elements.newRepoName.focus();
            return;
        }
        // 验证仓库名称格式
        if (!/^[a-zA-Z0-9_.-]+$/.test(repoName)) {
            ToastManager.show('仓库名称只能包含字母、数字、下划线、点号和连字符');
            DOMManager.elements.newRepoName.focus();
            return;
        }
        try {
            // 显示创建中状态
            const createBtn = DOMManager.elements.newRepoCreate;
            const originalText = createBtn.innerHTML;
            createBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 创建中...';
            createBtn.disabled = true;
            // 调用 createRepository 方法
            await this.createRepository(repoName, repoDesc, isPrivate);
            DialogManager.hideNewRepoDialog();
            // 新建仓库后刷新仓库列表
            AutoRefreshManager.refreshWithCacheClear();
            
        } catch (error) {
            console.error('处理新建仓库错误:', error);
        } finally {
            // 恢复按钮状态
            const createBtn = DOMManager.elements.newRepoCreate;
            createBtn.innerHTML = '创建';
            createBtn.disabled = false;
        }
    },

    // 处理文件上传 - 添加文件大小限制
    async handleFileUpload() {
        if (!DOMManager.elements.fileInput.files || DOMManager.elements.fileInput.files.length === 0) {
            ToastManager.show('请先选择文件');
            return;
        }
        try {
            const files = Array.from(DOMManager.elements.fileInput.files);
            
            // 检查文件大小 (GitHub限制单个文件最大100MB)
            const oversizedFiles = files.filter(file => file.size > 100 * 1024 * 1024);
            if (oversizedFiles.length > 0) {
                ToastManager.show(`文件 ${oversizedFiles[0].name} 超过100MB限制`);
                return;
            }
            let successfulUploads = 0;
            let failedUploads = 0;
            
            // 显示上传进度
            const progressToast = ToastManager.createProgressToast(`准备上传 ${files.length} 个文件...`);
            DialogManager.hideUploadDialog();
            // 顺序上传每个文件
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                try {
                    progressToast.textContent = `正在上传 ${i+1}/${files.length}: ${file.name}...`;
                    
                    await this.uploadSingleFile(file);
                    successfulUploads++;
                    
                    // 小延迟避免速率限制
                    if (i < files.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                } catch (error) {
                    console.error(`文件 ${file.name} 上传失败:`, error);
                    failedUploads++;
                    
                    // 如果是速率限制错误，等待一段时间再继续
                    if (error.message.includes('API rate limit')) {
                        progressToast.textContent = `遇到速率限制，等待60秒后继续...`;
                        await new Promise(resolve => setTimeout(resolve, 60000));
                        i--; // 重试当前文件
                        continue;
                    }
                }
            }
            
            // 上传完成后清除当前目录缓存（关键）
            StateManager.clearDirectoryCache(StateManager.currentRepo, StateManager.currentPath);
            
            ToastManager.removeProgressToast();
            
            if (failedUploads === 0) {
                ToastManager.show(`成功上传 ${successfulUploads} 个文件`);
            } else {
                ToastManager.show(`上传完成: ${successfulUploads} 成功, ${failedUploads} 失败`);
            }
            
            // 上传文件后刷新当前目录           
AutoRefreshManager.refreshAfterFileOperation();
        } catch (error) {
            console.error('上传过程中发生错误:', error);
            ToastManager.show('上传过程中发生错误: ' + error.message);
        } finally {
            DOMManager.elements.fileInput.value = '';
        }
    },
    // 上传单个文件
    async uploadSingleFile(file) {
        try {
            // 1. 读取文件内容为Base64 - 使用更可靠的方法
            const base64Content = await this.readFileAsBase64(file);
            
            // 2. 构建文件路径
            const filePath = StateManager.currentPath ?
                `${StateManager.currentPath}/${file.name}` : file.name;
            
            // 3. 检查文件是否存在并获取SHA - 使用新的检查方法
            const fileInfo = await this.getFileInfoIfExists(filePath);
            
            // 4. 构建上传数据
            const uploadData = {
                message: `Upload ${file.name}`,
                content: base64Content
            };
            
            // 如果文件已存在，添加SHA用于更新
            if (fileInfo && fileInfo.sha) {
                uploadData.sha = fileInfo.sha;
            }
            
            // 5. 执行上传
            const response = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(uploadData)
                }
            );
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || `上传失败: ${response.status}`);
            }
            return { file: file.name, status: 'success' };
        } catch (error) {
            console.error(`文件 ${file.name} 上传失败:`, error);
            throw error;
        }
    },

    // 检查文件是否存在并返回文件信息
    async getFileInfoIfExists(filePath) {
        try {
            const response = await fetch(
                `https://api.github.com/repos/${StateManager.currentRepo}/contents/${encodeURIComponent(filePath)}`,
                {
                    headers: {
                        'Authorization': `token ${StateManager.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                }
            );
            
            if (response.ok) {
                const data = await response.json();
                return { sha: data.sha, exists: true };
            } else if (response.status === 404) {
                return null; // 文件不存在
            } else {
                const errorData = await response.json();
                throw new Error(errorData.message || '检查文件状态失败');
            }
        } catch (error) {
            console.error('检查文件存在性错误:', error);
            return null;
        }
    },

    // 可靠的文件读取为Base64
    readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                // 将ArrayBuffer转换为base64
                const arrayBuffer = reader.result;
                const uint8Array = new Uint8Array(arrayBuffer);
                let binaryString = '';
                uint8Array.forEach(byte => {
                    binaryString += String.fromCharCode(byte);
                });
                resolve(btoa(binaryString));
            };
            reader.onerror = () => reject(new Error('文件读取失败'));
            reader.readAsArrayBuffer(file);
        });
    },

    // 启用 GitHub Pages
    async enableGitHubPages() {
        const enableBtn = DOMManager.elements.staticSiteEnable;
        const originalText = enableBtn.innerHTML;
        
        try {
            // 显示加载状态
            enableBtn.disabled = true;
            enableBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 处理中...';
            
            // 获取目标仓库
            const targetRepo = StateManager.contextMenuTarget ?
                ContextMenuManager.getTargetRepo(StateManager.contextMenuTarget) :
                StateManager.currentRepo;
                
            const [owner, repoName] = targetRepo.split('/');
            const branch = DOMManager.elements.pagesBranch.value;
            const path = DOMManager.elements.pagesFolder.value === '/docs' ? '/docs' : '/';
            
            console.log('启用 Pages 参数:', { owner, repoName, branch, path });
            
            await APIService.enableGitHubPages(owner, repoName, branch, path);
            
            // 更新状态映射
            StateManager.pagesEnabledMap.set(targetRepo, true);
            
            ToastManager.show(`网站已部署: ${targetRepo}`);
DialogManager.hideStaticSiteDialog();

// 启用Pages后刷新当前视图
AutoRefreshManager.refreshAfterFileOperation();

// 更新菜单按钮状态
if (StateManager.contextMenuTarget) {
    setTimeout(() => {
        ContextMenuManager.updatePagesMenuButton(StateManager.contextMenuTarget);
    }, 1000);
}
            
            // 清除上下文菜单目标
            StateManager.contextMenuTarget = null;
            
        } catch (error) {
            console.error('部署网站错误:', error);
            ToastManager.show('操作失败: ' + error.message);
            
            // 恢复按钮状态
            enableBtn.disabled = false;
            enableBtn.innerHTML = originalText;
        }
    },

    // 处理复刻仓库
    async handleForkRepo() {
        const repoUrl = DOMManager.elements.forkRepoUrl.value.trim();
        if (repoUrl) {
            await this.forkRepository(repoUrl);
        } else {
            ToastManager.show('请输入GitHub仓库URL');
        }
    },

    // 复刻仓库
    async forkRepository(repoUrl) {
        try {
            // 从URL中提取owner和repo名称
            const urlPattern = /https:\/\/github\.com\/([^\/]+)\/([^\/]+)/i;
            const match = repoUrl.match(urlPattern);
            
            if (!match || match.length < 3) {
                throw new Error('无效的GitHub仓库URL');
            }
            
            const owner = match[1];
            const repo = match[2];
            
            ToastManager.show('正在复刻仓库...');
            DialogManager.hideForkRepoDialog();
            
            await APIService.forkRepository(owner, repo);
            
            ToastManager.show('仓库复刻中，请稍后刷新查看...');
            
            // 8秒后自动刷新
            setTimeout(() => {
                NavigationManager.loadRepositories();
            }, 8000);
            
        } catch (error) {
            console.error('复刻仓库错误:', error);
            ToastManager.show('复刻仓库失败: ' + error.message);
        }
    },

    // 关闭构建状态
    closeBuildStatus() {
        DOMManager.elements.buildStatus.classList.add('hidden');
        clearInterval(StateManager.buildTimer);
        StateManager.buildStatus = null;
    }
};

// ==================== 内存泄漏预防清理模块 ====================
const MemoryCleanupManager = {
    // 跟踪需要清理的资源引用
    trackedResources: {
        eventListeners: new Map(), // 存储事件监听器映射（元素→事件类型→处理函数）
        timers: new Set(), // 存储定时器ID
        blobUrls: new Set(), // 存储创建的Blob URL
        domElements: new Set(), // 存储动态创建的DOM元素
        monacoModels: new Set() // 存储Monaco编辑器模型
    },

    // 初始化清理机制
    init() {
        // 监听页面卸载，执行最终清理
        window.addEventListener('beforeunload', () => this.fullCleanup());
        // 监听编辑器关闭，清理编辑器相关资源
        this.hookEditorClose();
        // 监听对话框关闭，清理对话框相关资源
        this.hookDialogClose();
        // 重写定时器方法，自动跟踪
        this.hookTimerMethods();
        // 重写Blob URL创建方法，自动跟踪
        this.hookBlobUrlMethods();
    },

    // 跟踪事件监听器（供外部模块调用，无需改动原有代码，按需手动注册）
    trackEventListener(element, eventType, handler) {
        if (!this.trackedResources.eventListeners.has(element)) {
            this.trackedResources.eventListeners.set(element, new Map());
        }
        const eventMap = this.trackedResources.eventListeners.get(element);
        if (!eventMap.has(eventType)) {
            eventMap.set(eventType, new Set());
        }
        eventMap.get(eventType).add(handler);
    },

    // 跟踪动态创建的DOM元素
    trackDomElement(element) {
        this.trackedResources.domElements.add(element);
    },

    // 跟踪Monaco编辑器模型
    trackMonacoModel(model) {
        if (model && model.dispose) {
            this.trackedResources.monacoModels.add(model);
        }
    },

    // 钩子：编辑器关闭时清理
    hookEditorClose() {
        const originalClose = EditorManager.closeEditor;
        EditorManager.closeEditor = function() {
            // 执行原有关闭逻辑
            originalClose.call(this);
            // 清理编辑器资源
            MemoryCleanupManager.cleanupEditorResources();
        };
    },

    // 钩子：对话框关闭时清理
    hookDialogClose() {
        const dialogs = [
            'confirm-dialog', 'new-folder-dialog', 'new-repo-dialog',
            'fork-repo-dialog', 'upload-dialog', 'static-site-dialog'
        ];
        dialogs.forEach(dialogId => {
            const dialog = document.getElementById(dialogId);
            if (dialog) {
                const originalHide = DialogManager.hideDialog;
                DialogManager.hideDialog = function(element) {
                    originalHide.call(this, element);
                    if (element.id === dialogId) {
                        MemoryCleanupManager.cleanupDialogResources(element);
                    }
                };
            }
        });
    },

    // 钩子：定时器方法重写（setTimeout/setInterval）
    hookTimerMethods() {
        const originalSetTimeout = window.setTimeout;
        window.setTimeout = function(callback, delay, ...args) {
            const timerId = originalSetTimeout(callback, delay, ...args);
            MemoryCleanupManager.trackedResources.timers.add(timerId);
            return timerId;
        };

        const originalSetInterval = window.setInterval;
        window.setInterval = function(callback, delay, ...args) {
            const timerId = originalSetInterval(callback, delay, ...args);
            MemoryCleanupManager.trackedResources.timers.add(timerId);
            return timerId;
        };

        const originalClearTimeout = window.clearTimeout;
        window.clearTimeout = function(timerId) {
            originalClearTimeout(timerId);
            MemoryCleanupManager.trackedResources.timers.delete(timerId);
        };

        const originalClearInterval = window.clearInterval;
        window.clearInterval = function(timerId) {
            originalClearInterval(timerId);
            MemoryCleanupManager.trackedResources.timers.delete(timerId);
        };
    },

    // 钩子：Blob URL方法重写
    hookBlobUrlMethods() {
        const originalCreateObjectURL = window.URL.createObjectURL;
        window.URL.createObjectURL = function(blob) {
            const url = originalCreateObjectURL(blob);
            MemoryCleanupManager.trackedResources.blobUrls.add(url);
            return url;
        };

        const originalRevokeObjectURL = window.URL.revokeObjectURL;
        window.URL.revokeObjectURL = function(url) {
            originalRevokeObjectURL(url);
            MemoryCleanupManager.trackedResources.blobUrls.delete(url);
        };
    },

    // 清理编辑器相关资源
    cleanupEditorResources() {
        // 销毁Monaco编辑器模型
        this.trackedResources.monacoModels.forEach(model => {
            try {
                model.dispose();
            } catch (e) {}
        });
        this.trackedResources.monacoModels.clear();

        // 清理编辑器相关定时器
        this.trackedResources.timers.forEach(timerId => {
            clearTimeout(timerId);
            clearInterval(timerId);
        });
        this.trackedResources.timers.clear();
    },

    // 清理对话框相关资源
    cleanupDialogResources(dialogElement) {
        // 移除对话框内的临时事件监听器
        const eventMap = this.trackedResources.eventListeners.get(dialogElement);
        if (eventMap) {
            eventMap.forEach((handlers, eventType) => {
                handlers.forEach(handler => {
                    dialogElement.removeEventListener(eventType, handler);
                });
            });
            this.trackedResources.eventListeners.delete(dialogElement);
        }
    },

    // 全量清理所有资源
    fullCleanup() {
        // 清理事件监听器
        this.trackedResources.eventListeners.forEach((eventMap, element) => {
            eventMap.forEach((handlers, eventType) => {
                handlers.forEach(handler => {
                    try {
                        element.removeEventListener(eventType, handler);
                    } catch (e) {}
                });
            });
        });
        this.trackedResources.eventListeners.clear();

        // 清理定时器
        this.trackedResources.timers.forEach(timerId => {
            clearTimeout(timerId);
            clearInterval(timerId);
        });
        this.trackedResources.timers.clear();

        // 清理Blob URL
        this.trackedResources.blobUrls.forEach(url => {
            try {
                window.URL.revokeObjectURL(url);
            } catch (e) {}
        });
        this.trackedResources.blobUrls.clear();

        // 清理动态DOM元素
        this.trackedResources.domElements.forEach(element => {
            try {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            } catch (e) {}
        });
        this.trackedResources.domElements.clear();

        // 清理Monaco模型
        this.cleanupEditorResources();

        // 清理构建状态定时器
        if (StateManager.buildTimer) {
            clearInterval(StateManager.buildTimer);
            StateManager.buildTimer = null;
        }
    }
};

// 初始化内存清理模块（页面加载时自动执行）
document.addEventListener('DOMContentLoaded', () => {
    MemoryCleanupManager.init();
});

// 初始化应用
document.addEventListener('DOMContentLoaded', () => {
    App.init();
});


    </script>
</body>
</html>